
% resource management in the DC
% -------------------
% Resource Management
% -------------------

In this section we cover resource location systems, starting by discussing the types of queries that can be supported by resource location systems, then we cover the query dissemination strategies that are commonly employed when implementing this type of service, and finally cover the different types of architectures for these services.

Given that the main challenge to solve is to provide a platform which enables monitoring of edge devices and tasks running on them, it is imperative that peers are able to find the resources they need (e.g. services, peers or computing power) to meet their requests. For this, peers require a \textbf{resource location system}.

Resource location systems are one of the most common applications of the P2P paradigm. In these systems, a participant provided with a resource descriptor is able to query peers and obtain an answer to the location (or absence) of that resource in the system within a reasonable amount of time. Following, we providing a brief taxonomy of common querying techniques employed in resource location systems:

\begin{enumerate}
    \item \textbf{Exact Match queries} specify the resource to search by the value of a specific attribute (for example, a hash of the value).

    \item \textbf{Keyword queries} employ one or more keywords (or tags) combined with logical operators to describe resources (e.g. "pop", "rock", "pop and rock" ...). These queries return a list of resources and peers that own a resource whose description matches the keyword(s).
    
    \item \textbf{Range queries} retrieve all resources whose value is contained in a given interval (e.g. "movies with 100 to 300 minutes of duration"). These queries are especially applied in databases.
    
    \item \textbf{Arbitrary queries} are queries that aim to find a set of nodes or resources that satisfy one or more arbitrary conditions, a possible example of an arbitrary query is looking for a set resources with a certain size or format.
    
\end{enumerate}

\subsection{Centralized Resource Location}

\textbf{Centralized resource location} relies on one (or a group of) centralized peers that index all resources in the system. This type of architecture greatly reduces the complexity of systems, as peers only need to contact a subset of nodes to locate resources. 

It is important to notice that in a centralized architecture, while the indexation of resources is centralized, the resource access may still be distributed (e.g. a centralized server provides the addresses of peers who have the files, and files are obtained in a pure P2P fashion), a system which employs this architecture with success is BitTorrent \cite{cohen2003incentives}.

Although centralized architectures are widely used nowadays, they lack the necessary scalability to index the large number of resources we intend to manage, and have limited fault tolerance to failures, which makes centralized resource location systems unsuited for edge environments. 

%However, there are many ways that a hybrid architecture can be applied to Edge computing: since the failure rate of a single data center (DC) is low, if we assume a system composed by multiple DCs, they may act as a reliable failover for whenever edge devices are partitioned of fail. 

\subsection{Decentralized Resource Location}

In decentralized resource location systems, the resources (or their indexes) are scattered among all peers in the system, by consequence, peers in these systems search for the resources they need by disseminating queries, we now study popular techniques in the literature.

\subsubsection{Query Dissemination Techniques}

There are two popular approaches for disseminating queries in a decentralized resource location system, \textbf{flooding} and \textbf{random walks}. When \textbf{flooding}, peers eagerly forward queries to other peers in the system, the objective of flooding is to contact a certain number of distinct peers in the system that may have the queried resource.

One approach is \textbf{complete flooding}, which consists in contacting every node in the system, this guarantees that if the resource exists, it will be found (this is the only way to provide exact resource location in a decentralized resource location system), however, complete flooding is not scalable and incurs lots of message redundancy. 

\textbf{Flooding with limited horizon} minimizes the message redundancy overhead by attaching a TTL to messages that limits the number of times a message can be retransmitted. However, there is a trade-off for efficiency: flooding with limited horizon does not provide exact resource location. There are many other dissemination techniques, often tailored towards specific application requirements.

\textbf{Random Walks} are a dissemination strategy that attempts to minimize the communication overhead that accompanies flooding. Instead of flooding, a random walk consists of a message with a TTL that is randomly forwarded one peer at a time throughout the network. Walks may also attempt to forward queries to neighbors which are more likely to have answers \cite{1022239}, this technique called a \textbf{random guided walk}. A common approach to bias random walks is to use bloom filters \cite{5751342}, which are space-efficient probabilistic data structures that support set membership queries.

\subsubsection{Resource Location on Unstructured Overlays}

First generation of decentralized resource location systems like Gnutella \cite{gnutella_gtk} employed unstructured flat overlays, and peers relied on simple broadcasts with limited horizon to query other peers in the system. However, as the size of the system grew, simple flooding techniques lacked the required scalability for satisfying the rising number of queries, which triggered the emergence of new techniques to reduce the number of messages per query, called \textbf{super-peers}. 

\textbf{Super-peers}, which are peers that have increased capacity and stability, these are assigned special roles in the system, in the case of resource location systems, super-peers disseminate queries throughout the system or cache file locations. This is the approach taken by Gia \cite{Chawathe2003} towards effectively reducing the number of peers that have to disseminate queries in Gnutella \cite{gnutella_gtk}. Following, we study super-peer systems in the literature.

\subsubsection*{Overnesia}

\textbf{Overnesia} \cite{leitao2014overnesia} is a protocol which creates virtual super-peers by maintaining fully connected groups of nodes with the same identifier known by all elements in the group. Nodes join the system by sending a JOIN request to a bootstrap node which triggers a random walk, the requesting node joins the group where random walk finishes (either because it finds an underpopulated group or because the TTL expires). Then, in order to promote intra-group membership consistency, nodes employ an anti-entropy mechanism where they periodically exchange messages containing their own view of the group. 

When a group detects that its size has become too large, it triggers a dividing procedure which splits the groups in two halves. This division reduces the costs of replicating data among its members, but also promotes good load-balancing of the system. Conversely, when the group size has fallen bellow a certain threshold, Overnesia triggers a collapse procedure, where each node takes the initiative to relocate itself to another group, resulting in the collapse of the group. Finally, nodes perform random walks along the overlay in order to establish inter-group links which in turn use to perform efficient broadcasts.

\subsubsection*{SOSP-net}

SOSP-Net \cite{garbacki2007optimizing}  (Self-Organizing Super-Peer Network) proposes a resource location system composed by weak peers and super-peers that effectively employs feedback concerning previous queries to improve the overlay network. 

Weak peers maintain links to super-peers which are biased based on the success of previous queries, and super peers bias the routing of queries by taking into account the semantic content of each query. 

\subsubsection{Resource Location on Structured Overlays}

\textbf{Distributed Hash Tables} (DHTs) are a form of structured overlay that is very popular in resource location systems. As previously mentioned, in a DHT, peers use consistent hash functions to generate node IDs which are uniformly distributed over the id space. Intuitively, employing the same hash function to generate resource IDs, peers are able to map resources to specific peers in the system, which makes them suitable for (\textbf{exact match queries}).

One particular type of DHT that is commonly employed in small sized resource location systems is the One-Hop Distributed Hash Table (DHT), nodes in a one-hop DHT have full membership of the system and, consequently, they can locally map resources to known peers and perform lookups in O(1) time and message complexity. Facebook's Cassandra \cite{lakshman2010cassandra} and Amazon's Dynamo \cite{decandia2007dynamo} are widely used implementations of one-hop DHTs. 

\subsection{Discussion}

As previously mentioned, centralized resource location systems are unsuited for edge environments due to their lack of scalability and fault-tolerance.

Unstructured resource location systems are attractive to perform queries that search for resources which are abundant in the system, however, this approach is inefficient when performing exact match queries, as a finding the exact resource in an unstructured resource location system requires flooding the entire system with messages. Conversely, structured resource location systems are specially tailored towards exact match queries, but are less robust to churn and subject to low-capacity nodes being a bottleneck in routing procedures. 

%\subsection{Hybrid approaches}

%\textbf{Curiata} \& \textbf{Build One Get One Free}

% TODO falar de surrogate routing
%\textcolor{red}{surrogate routing}

%\paragraph{\textbf{Viceroy} }

%\paragraph{\textbf{Koala} }

% TODO falar de otimizacoes fixes observadas:
% lazyness a montar a rede (usar mensagens de servicos)
% manter peers antigos (churn inversamente proporcional a uptime)
% formar grupos para reduzir routing (increased background communication)
% ao usar prefix routing consegue-se logb(n) routing
% Xor-distance vs numeric distance (unidirectionality)
% Pedidos assincronos para fazer queries mais rapidas
% usar um algoritmo para dar "feed" ao outro (gossip + dht)


