
% -------------------
% Topology Management
% -------------------
\subsection{P2P systems}

As previously mentioned, a challenge towards solving the proposed solution is to federate all peers in an abstraction layer that allows intercommunication and efficient resource discovery. Given that this is a classic P2P problem, this section provides context about P2P systems and how they usually organize.

In P2P, participants contribute to the system with a portion of their resources,so that that the overall system can accomplish tasks that would otherwise be impossible for a single peer to solve. However, due to memory and communication overhead, it is undesirable that all nodes in a P2P system collaborate with all other peers (unless in specific scenarios which we will further elaborate). 

Peers select a subset of peers in the system to establish neighboring relations. These neighboring relations are usually constructed on top links from an already existing network (commonly called an underlay). The accumulation of neighboring relations on top of the underlay network is what constitutes the \textbf{overlay network}. Overlay networks are commonly categorized in four categories: structured, unstructured, flat, and hierarchical:

\subsection{Unstructured overlays}

\textbf{Unstructured overlays} usually impose little to no rules in neighboring relations, peers may pick random peers to be their neighbors, or alternatively employ strategies to "rank" neighbors and selectively pick the "best". A key factor of unstructured overlays is that nodes can easily replace failed neighbors. Which provides a low maintenance overhead and provides high resilience to participants concurrently entering and leaving the system (this is called churn \cite{stutzbach2006understanding}). Unstructured overlays present an attractive option to federate edge devices, as edge devices do not need use many resources to join and participate in the system, and can easily adapt to the dynamic environment.

\textbf{Scamp}

\textbf{Hyparview}

\textbf{Overnesia}

\subsection{Structured overlays} 

\textbf{Structured overlays} enforce strong rules towards neighbor selection (generally based on identifiers of peers). As a result, the overlay generally converges to a topology known a priori, where the target topologies are normally tailored towards applicational requirements. A canonical example of a type of structured overlay is a distributed hash table (DHT), peers in a DHT use consistent hashing functions to select random identifiers that are uniformly distributed over the identifier space. Then, DHTs offer efficient routing capabilities over the identifier space (usually routing procedures take a logarithmic number of steps). DHTs have been extensibly used to support many large scale services (publish-subscribe, file sharing, among others) and are especially used in Cloud-based environments. 

\subsection{Hierarchical and flat overlays}

\textbf{Flat or hierarchical overlays} Flat overlays are composed by peers that evenly share the tasks of the system, there is no differentiation between the resources that peers have to contribute to  the system. Contrary their flat counterpart, hierarchical overlays may be characterized as overlays where peers have different tasks in the system according to their roles, this is an easy way to accommodate device heterogeneity while potentially increasing the performance of the system. Hierarchical structures can be applied to both structured and unstructured overlays: in the case of unstructured overlays, the canonical example is \textbf{super-peers}, which are peers that have increased capacity and stability, this is the approach taken by Gia \cite{Chawathe2003} to improve the scalability of Gnutella \cite{gnutella_gtk}. Super Peers are commonly assigned with the task of disseminating queries throughout the system so that other peers do not have to. This technique effectively reduces the number of peers that have to exchange messages, which by consequence raises system scalability, however, this approach is still inefficient when finding rare resources in the system. The second approach to building a hierarchical topology is to employ a DHT, hierarchical DHTS usually form contained DHTS within other DHTS (e.g. a ring within a ring). This offers several important advantages over a flat DHT: first, lookups take less hops and messages to reach the target, second, organizing nodes in disjoint groups allows traffic locality if groups of nodes are close in the underlay, finally, churn events within a group stay contained within that group. However, many of these systems either employ more memory to accommodate the many levels hierarchical DHT, or tradeoff reliability (by shortening the number of connections) for memory and communication efficiency.

\subsection{Evaluating topologies}

Given that the accumulation of the neighboring relations among peers form a graph, one can define a set of metrics in order to measure direct properties of overlay topologies. Following, we list direct metrics to measure overlay performance:

\begin{enumerate}
    
    \item \textbf{Connectivity}. A connected graph is one where there is at least one path from each node to all other nodes in the system. The absence of this property means that there are nodes in the system that are isolated, thus will not be able to cooperate towards the overall behavior of the system. This property is usually measured as a percentage, corresponding to the largest portion of the system that is connected. Intuitively, a  connected overlay has 100\% connectivity.
    
    \item \textbf{Degree Distribution}. The degree of a node consists in the number of arcs that are connected to it. Depending on the type of system, the connections may be directed or indirected, in a directed graph there is a distinction between \textbf{in-degree} and \textbf{out-degree} of a node. Intuitively, nodes with a high in-degree have higher reachability in the system, and nodes with 0 in-degree cannot be reached. In flat overlays, where load distribution is desired, degree distribution should be as similar as possible in all nodes. By contrast, in hierarchical overlays,  designs take advantage of device heterogeneity to differentiate between peers and promote scalability.
    
    \item \textbf{Average Shortest Path}. A path is composed by the edges of the graph that a message would have to cross to get from one node to other. The average shortest path consists in the average of all those paths, to promote efficient communication patterns, is desirable that this value is as low as possible.
    
    \item \textbf{Clustering Coefficient}. The clustering coefficient provides a measure of the density of neighboring relations across the neighbors of a given node. It consists in the number of a node's neighbors divided by the maximum number of links between those neighbors. Similar to the average shortest path, the clustering coefficient of an overlay consists in the average of the clustering coefficient of all the peers. A high value of clustering coefficients will result in a higher number of redundant messages, and by consequence, additional localized traffic. Finally, areas of an overlay with a higher clustering coefficient tend to be more easily isolated from the remaining system.
    
    \item \textbf{Overlay Cost}. If we assume that a link in the overlay has a \textit{cost}, then the overlay cost is the sum of all the links that form the overlay. Link cost can derive from overlay metrics (numeric distance, XOR distance, etc), or external metrics such as latency.
    
\end{enumerate}

\subsection{Discussion}
