\chapter{Related Work}
\label{cha:related_work}


\section{Peer to Peer} % (fold)
\label{sec:p2p}

The Peer to Peer (P2P) paradigm has been extensibly used to implement distributed, scalable, fault-tolerant services, it overcomes limitations such as scalability and fault-tolerance that arise from the client-server model. 

Collaboration is the foundation of P2P systems, it is the foundation of the scalability provided by P2P. participants of the system (peers) perform tasks that contribute towards a common goal which is beneficial for the overall functioning of the system. Collaboration enables P2P systems that accomplish tasks would otherwise be impossible by an individual server.  % citations

Peers contribute with a portion of their resources (such as computing, memory or network bandwidth, e.t.c) to other participants as well as consume resources from other peers in the system. This contrasts with the traditional client-server paradigm where the consumption and supply of resources is decoupled. Finally, fault tolerance is achieved by the absence of a centralized point of failure.

There are many types of services that are based on P2P systems, however, most popular types of services build on this paradigm are: resource location, content delivery, cryptocurrency or blockchain, e.t.c.. Popular services built on this paradigm are file sharing applications, (e.g. Napster, BitTorrent, Emule and Gnutella), cryptocurrencies (bitcoin), streaming (Skype), anonymity (TOR) among others. 

One factor that imposes a crucial difference in how these systems behave is the membership information, a participant in the system that knows every other participant in the system is said to have full membership information, the alternative is called partial membership, where a peer is only aware of a partial number of elements in the system.

Full membership systems are usually employed in small to medium sized storage solutions like on One-Hop DHTs e.g. Kademlia, Amazon's Dynamo and DynamoDB. However, full membership solutions tend to have scalability problems and behave poorly in the face of churn (participants leaving and entering the system), which increases the workload necessary to maintain the membership information up-to-date. 

% citations

Partial membership systems rely on some membership mechanism that restricts each peer to only have a few neighboring relations that are used to perform communication (usually through message exchanges) between each other. Similarly to full membership, the number of connections a peer has  dictates the scalability of the system, where systems with larger views will have a harder time maintaining them. The accumulation of the partial views of all peers in the system dictates the topology of the overlay network.

\section{Topology Management}
\label{sec:topology_mgmt}

Topology management consists in the creation and management of an \textbf{overlay network}, which consists in a logical network built on top of another network (usually the internet). Elements of overlays are connected through virtual links that are a combination of one or more underlying physical links.

The way the aforementioned links are organized dictate the type of overlay: if the links are logically organized by some metric, we call it a \textbf{structured overlay}. On contrary, when there are no restrictions form the links, we call it an \textbf{unstructured overlay}. Services then leverage on the topologies that are tailored as closely as possible towards application requirements to build services.

\subsection{Structured overlays}

Structured overlays impose restrictions over the neighboring relations that can be established among peers, often based on the identifier of each participant of the system. Usually these identifiers are unique and are independently generated by each peer, then peers employ a global coordination mechanism to tightly control the topology. Examples of common resulting topologies of structured overlays are rings, meshes, hypercubes, among others.

As previously mentioned, a widely used type of structured overlays are distributed hash tables (DHT
). Often, DHT's provide application-level routing by employing topologies that can be transversed in logarithmic time. Then, using hash functions to map objects (files, multimedia, messages, e.t.c) to the peer identifier space, and assigning a key-space interval to each peer, peers can find the peer responsible for any key in a logarithmic number of steps. 

DHT's have been extensibly used to support many large-scale different types of services (publish-subscribe, resource location, monitoring, e.t.c) and are especially used in Cloud-based environments. Their popularity derives from providing the previously mentioned functionality while maintaining very little membership information (typically 1\% of the peers).

However, a DHT's behavior depends on the correctness of the topology, and when in the presence of high churn or network partitions / failures, the correctness of the topology is harder to maintain, nodes must exchange more messages to ensure that the topology is correct. Additionally, whenever a node fails, DHT's rely on the correctness of the routing infrastructure to replace the failed node,
this means that if there is a failure in the routing infrastructure, the DHT may become unrepairable.

% citations

Following we present some popular implementations of structured overlays:

\begin{itemize}
    
    \item Chord is a distributed lookup protocol that addresses the need to locate the node that stores a particular data item, it specifies how to find the locations of keys, how nodes recover from failures and how nodes join the system. 
    
    Chord's behavior is as follows: it employs consistent hashing to assign each node and key an m-bit identifier, the higher m is, the higher probability of achieving better load distribution among peers (peers receive roughly the same number of keys). Peers are ordered by identifier in a clockwise circle, then, any key \(k\) is assigned to the first peer whose identifier is equal or follows k in the identifier space. 
    
    Queries for a given identifier can be passed around the circle via these successor pointers until they find a peer that succeeds the identifier, this is the node that the query maps to. However, this approach by itself is inefficient because it may require transversing the whole circle to find the target. 
    
    To evade this limitation, Chord implements a system of "shortcuts" called the \textbf{finger table}. The finger table contains at most \(m\) entries, each $i$th entry of this table corresponds to the first peer that succeeds a certain peer \(n\) by \($2$^$i$th\) in the circle.
    This means that whenever the finger table is up-to-date, lookups only take logarithmic time to finish. 
    
    \item Pastry
    
    \item Kelips
    
\end{itemize}



\subsection{Random overlays}

\subsection{Self-adapting overlays}

\section{Aggregation} 
\label{sec:aggregation}

\subsection{Types of aggregation}

\subsection{Relevant aggregation protocols}

\section{Resource Discovery} 
\label{sec:res_discvovery}

\section{Offloading computation to the edge} 
\label{sec:offloading_comp}