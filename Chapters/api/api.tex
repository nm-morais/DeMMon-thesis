
The API is the last module of the devised framework. As previously mentioned, the purpose of this module is to expose the functionality of the remaining components of the framework by mediating the interactions between the clients and the remaining modules via well-defined operations. In this section, we provide a brief overview of the API implementation and detail its most relevant operations. 

\subsection{Overview}

This API is coalesced by a message-based protocol performed via WebSockets \todo{citation?}. The choice of using a message-based protocol is motivated by the fact that, contrary to traditional HTTP APIs, messages enable clients to receive events sent by the DeMMon servers. This feature is essential for both alerting (as triggered alarms need to be propagated to their issuing clients) and for issuing events such as active view changes to subscribed clients. Consequently, in this API, the client must first establish a connection with the server in order to perform operations, this is done via an HTTP server, which contains a single endpoint, used for establishing the WebSockets connection. In order to test the provided API and the capabilities of the framework, we also devised a client which performs the operations, available on \todo{put repo in}.

When connected, clients and servers exchange JSON formatted messages which may contain messages related to the behaviour of two types of operations: the first is a \textbf{request}, which is similar to an HTTP request, where the client creates a request and assigns it an ID which it sends to the deMMon server via a WebSockets message. When the server receives the message, it processes it and sends back to the client a reply message containing the ID and the reply contents using the same established connection. Requests are used, for example, for querying metrics. The second type of operation is a \textbf{subscription}, which initially performs similarly to a request, hovever, in this operation the server, posterior to the initial request, may send sporadic messages to the client containing events related to the issued subscription. This type of operation is used, for example, for both clients wanting to receive active view changes or for clients installing alarms and then receiving updates to changes in these alarms.

With this, we now provide a brief overview of what we believe to be the more relevant operations exposed by the deMMon API.

\subsubsection{API operations}

\begin{enumerate}
    \item \textbf{Install or remove buckets} These operations, as their name indicates, insert or remove buckets from the time series database. As previously mentioned in section \todo{ref}, buckets are containers for all time-series data with a certain name, periodicity and capacity. Whenever a ``create bucket'' operation is issued for a bucket with a name that collides with a pre-existing bucket (with a different periodicity), an error message is returned to the client.
    
    \item \textbf{Retrieve and insert metric values}. These two operations, performed via requests, add or extract values from the time series database. The insertion of values is performed using messages the metric values. When these messages are received, the values are inserted directly in the corresponding time series. The retrieval of metric values is also performed via a request containing a query in the devised query language. This query is passed to the monitoring module (specifically the metric engine) for processing. When the query has finished being processed by the metric engine, the result is sent back to the client via a message.
    
    \item \textbf{Subscription to active view updates}. This operation, as the name denotes, is performed via a subscription, where the initial reply contains the current view of the server. Then, whenever there is a change in the view of the deMMon server, it sends a message containing the change type (if either a new connection was established to a node, or if a previous connection disappeared).
    
    \item \textbf{Install continuous query}. This operation allows the installation of a continuous query. Continous queries are operations which contain multiple parameters, and are essentially queries that are evaluated at specified periodicities, and whose returning values are inserted into the time series database under a specified name. This operation is useful for applications that wish to, for example, resample their data to longer periodicities, or wish to calculate a certain aggregated value at specific intervals. 

    \item \textbf{Broadcast messages and subscribe to broadcast message receptions}. As the name indicates, these two operations refer to issuing and receiving broadcast messages. The emission of new broadcast messages is done via a request containing the message contents, the message TTL and the message ID (a text-based field). Whenever this request is received, the API sends a request to the overlay protocol, which in turn propagates the message contents via their active connections (until the TTL is 0). Broadcast messages are propagated and forwarded to peers in the active in a similar manner to the subscription messages (described in \todo{quote broadcast aggregation}). Finally, nodes can perform \textbf{Subscriptions to broadcast message receptions}, which are subscription operations for clients that wish to receive all messages with a certain ID that pass through the server's overlay protocol. 
    
    \item \textbf{Install Alarm}. This operation is coalesced by a subscription containing the parameters described in section \todo{citar seccao alarms}, whenever a client issues this operation, the API assigns a new ID to the alarm and adds it to the alarm manager (described in section \todo{ref}), where it begins being periodically verified. After this, if in any verification the alarm fires, the alarm manager notifies the API which in turn sends a message to the client with the firing alarm's ID.

    \item \textbf{Install and removal of neighborhood aggregation set}. These operations manage the operation of the neighborhood aggregation algorithm defined in section \todo{put ref to neigh agg}. These are performed via requests, in case of installation, these contain contain the parameters for the request mentioned in \todo{another ref to place}. Whenever the api receives a request for the creation of a neighborhood aggregation, it assigns an ID to it, and sends a reply to the client with the generated ID. Conversely, when the client no longer wishes to collect these values, it issues a removal request containing originally assigned ID of the aggregation set.

    \item \textbf{Install and removal of global aggregation function}. These operation initiate and stop the global aggregation procedure (described in subsection \todo{ref section global agg}), the behavior of this operation, in regard to the interaction betweeen the client and the server, is similar to the neighborhood aggregation set. However, nodes receiving this request become roots of their own global aggregation trees.

    \item \textbf{Install and remove tree aggregation function}. This is the last detailed operation of the deMMOn API, which in terms of interaction between the client and the server, behaves similarly to both the neighborhood and global aggregation requests. Whenever the API receives a request to begin global aggregation, it forwards it to the aggregation protocol, which begins the mechanism described in \todo{insert ref}.
\end{enumerate}

\todo{falar do cliente e do exporter}

\subsubsection{Summary}

In this section, we have presented an overview of the capabilities of the DeMMon API. We began by providing a brief overview of the interaction paradigm (message-based) and the reasons behind this choice. Next, we detailed the technologies used to realize this interaction paradigm and enumerated what we believe to be its most relevant operations. For each enumerated operation, we provided a brief explanation of its behaviour regarding both the effect on the remaining components and the model of interaction between the client and the server. 