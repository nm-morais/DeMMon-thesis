
\input{Chapters/membership/pseudocode/jlt-pseudocode.tex}

In this section, we discuss the design of the overlay network, which aims to build and maintain a latency and capacity-aware tree-shaped network (capacity represents one, or a combination of, values that denote the node's computing and networking power). We begin by providing the considered system model, then follow with an overview of the mechanisms responsible for building and maintaining the tree. Lastly, we conclude the chapter with a summary and discussion of the protocol.

\subsection{System Model}

The assumed system model is assumed to be a distributed scenario composed of nodes connected to the internet set-up such that they can send and receive messages via the internet (with an external IP or port-forwarding). We also assume that nodes are spread throughout a large area and have varied capacity values.

Regarding the fault model, we assume that all but a small portion of nodes (also known as the landmarks, which in our model represent DCs) can fail, and when other nodes fail, they do so in a crash-fault manner, stopping all emissions and receptions of messages. We assume landmarks have additional fault tolerance given their privileged infrastructure, and additionally, we assume other such as replication \cite{} mechanisms could be employed to ensure that faulty landmarks get replaced in case of failure. 
  
Finally, all nodes must run the same software stack with similar configuration settings and landmark values, installed a priori.

\subsection{Overview}

As previously mentioned, the main objective of the created protocol is to establish a latency and capacity-aware multi-tree-shaped overlay network, rooted in the previously mentioned landmarks. Our motivations for choosing the tree structure for the network are the following: (1) to map the cloud-edge environment, by rooting the trees on nodes running DCs in the cloud, and creating a hierarchical structure for other, less powerful, nodes to be coordinated from the roots \todo{isto e esticar?} (2) to be able to map the heterogeneity of each device in the environment: by biasing the placement of nodes in the tree such that nodes with higher capacity are placed higher in the tree, and nodes with lower capacity are biased towards lower levels of the tree, nodes are used more or less according to their capacity values; (3) the tree structure can be easily employed to perform efficient aggregations, by propagating and merging values recursively from the lower to the higher levels of the tree, which is the basis for the aggregation protocol presented in \todo{add ref}; and finally, (4) by leveraging on the tree structure, nodes can propagate information efficiently, given that, in a network composed of N nodes, broadcasts require only N-1 message transmissions to reach all nodes in the network. 

In order to ease the explanation of the protocol, it is important to define some terms which we will use frequently to explain the devised protocol. The tree structure the protocol aims to establish and maintain is observable in figure \todo{criar imagem para ilustrar estrutura resultante}, which, as previously referenced, is composed of multiple interconnected trees. The nodes connected to the landmarks (denoted their \textbf{children}) may themselves be the parent of their own children, which would have the landmark as their \textbf{grandparent}. Intuitively, the \textbf{descendants} of a node are all of its children and children's children, recursively, until the leaves. All nodes which share the same parent (\textbf{siblings}) are connected among themselves, forming a \textbf{group}, whose size is biased (but not guaranteed) to be within two configurable upper and lower bounds. Therefore, all nodes have active connections to their parent, children and siblings. The combination of a node's active connection may be called its \textbf{active view}. 

The devised algorithm is composed of three main mechanisms: (1) the \textbf{join} mechanism, which aims to establish the initial tree structures, (2) the \textbf{active view maintenance}, responsible for bounding the number of connections for each node, and optimizing the connections of each node, (3)  and finally \textbf{passive view maintenance}, responsible for collecting information about peers which are not in the active view, which are used for both fault tolerance and connection optimizations.

\subsubsection{Join mechanism} \label{sec:overlay_network:join}

The Join mechanism is the mechanism responsible for choosing the initial parent connection, which performs a greedy depth-first search to find a suitable low latency node in the network with more than zero children. This mechanism is the first to be executed by all nodes in the system, with the pseudocode presented in algorithm \ref{alg:memb:join}. 

\input{Chapters/membership/pseudocode/membership/memb_join-small.tex}

Its first step (line \ref{alg:memb:join:state}) is to initialize the state of the joining node, composed by: (1) a map of type Node containing all successfully contacted nodes so far the join process, (2) a collection of type Node and a set of timer ids for each contacted node, (3) the best node contacted so far in the join process, (4) a timer id for contacting the chosen node in the join process, and finally (5) a variable of type Node denoting the peer itself. The type ``Node'' is a collection of attributes regarding a node, composed of: (1) latency measured, (2) its current parent, (3) number of children, (4) whether the node replied to the message, (5) its IP, (6) an array of coordinates (denoting its measured latency to each landmark, used in passive view maintenance mechanism), and finally, (7) an array of its childrens' IP and their number of children.
 
Then, each node joins the system, the procedures taken to join the tree differ consonant the node is a landmark or not. Given that landmarks are the roots of the trees, they have no parent in the resulting overlay, and consequently, in the join algorithm, these nodes attempt to repeatedly establish a connection with other landmarks by sending a special message. Landmarks that receive this message will send a reply and establish a connection back (line \ref{alg:memb:join:add_land}). Any joining landmark node only stops sending messages to other landmarks when the respective reply is received.

Nodes that are not landmarks begin the process of choosing their initial parent, initiated by sending a JOIN message via a temporary TCP channel, measuring the latency, and issuing ``joinTimers'' for all tree roots (line \ref{alg:memb:join:contact_landm}), then the node awaits the responses from the contacted nodes, during this process, the joining node listens for any ``joinTimers'' which have triggered, or until any of the node measurements has been unsuccessful (meaning contacted nodes have exceeded their reply timeout), if this happens, in the case of the contacted node being a landmark, the joining node aborts the join process and waits a configurable amount of time until attempting to re-join the overlay again. If the timed-out node is not a landmark, then that node is excluded from the remaining of the join process, and the join process is resumed as normal (line \ref{alg:memb:join:exclusions}).

When a node receives a JOIN message, it sends a JOINREPLY message back to the original sender containing: its parent, itself, and its children (line \ref{alg:memb:join:recv_join}). When the joining node receives the joinReply, it discards those that are from a timed-out node or from any node whose parent was not contacted in the join process (the node changed parent during the join process). Then, whenever the joining node has either: received the JOINREPLY messages from all contacted nodes and stored the information (line \ref{alg:memb:join:recv_join_reply}), or they have been timed-out via the ``joinTimers'', it evaluates all contacted nodes, attempting to find the contacted node with the lowest latency which is a suitable parent, by performing the following verifications:

\begin{enumerate}
    \item Verify if the node already has any children or if the node is a landmark (and can become the parent of the joining node) (line \ref{alg:memb:join:verif_children}).
    
    \item Verify if there was a node already contacted previously which was a suitable parent and had lower latency, in case there was, the joining node sends a ``JoinRequest'' and sets up a ``JoinRequestTimer'' for that node, and stops the verification process. (line \ref{alg:memb:join:verif_vs_prev})

    \item Verify if the current node has both enough children, and has the lowest latency up to this point in the join process, then the joining node assigns it as its best node so far and starts a new recursive step by sending JOIN messages and measuring the children of that node which themselves have more than one children (line \ref{alg:memb:join:advance}). Note that if none the current nodes' children are suitable parents (i.e. have no children themselves), then the condition in line \ref{alg:memb:join:cond_go} is triggered and the joining node will request the current best node to be its parent.
\end{enumerate}

If none of the verified peers was suitable to start a new recursive step (line \ref{alg:memb:join:join_base_case}) (either had no children or all verified nodes had higher latency than a previously contacted node), then the node joining node sends a ``JoinRequest'' to that node and sets up a ``JoinRequestTimer'' for the best previously contacted node (any node which receives a ``JoinRequest'' message replies with a ``JoinRequestReply''). 

The join process is concluded with both the reception of a ``JoinRequestReply'' and the establishment of the connection between the sender and receiver of the message. If the ``JoinRequestTimer'' timer triggers while waiting for the response, the node will recursively fall back to the parent of the selected node or re-join the overlay later in case there is no parent available. 

\subsubsection{Active view maintenance} \label{sec:overlay_network:active_view_maint}

The second mechanism of the devised membership algorithm, called active view maintenance, is the mechanism responsible for maintaining the size of the groups. In sum, this mechanism is coordinated by each parent and achieved via sending messages to some of its children signalling that they should connect to another specified parent. It achieves this by choosing new parents to form new groups using latency and node capacity as heuristics for the parent choice, where the information necessary to employ these two heuristics is obtained via periodic transmission from every child to its parent. This mechanism only executes when a group exceeds its size limit and attempts to keep group sized near the maximum configured limit.

The pseudocode for this mechanism is presentend in algorithm \ref{alg:memb:active_view_maint}, and starts by defining the necessary state: the nodes' active view (parent, children, and siblings), and an auxiliary map of sets, which holds the latencies of each children to every other children. (lines \ref{alg:memb:active_view_maint:state_start}-\ref{alg:memb:active_view_maint:state_end}). 

\input{Chapters/membership/pseudocode/membership/memb_active_view_maintenance.tex}

The mechanism starts with the propagation of information from the parent to the children and vice-versa. As observable in lines \ref{alg:memb:active_view_maint:update}-\ref{alg:memb:active_view_maint:update_end}), each parent transmits to its children a list of its current siblings, and propagates to its parent the latency to each of its siblings. Then, when this information is received (lines \ref{alg:memb:active_view_maint:update_recv_par} and \ref{alg:memb:active_view_maint:update_recv_chi}), it is merged into their local states for later use.

The second part of this mechanism is also periodic and is responsible for maintaining the group sizes by creating new parents or by sending children to already created groups (line \ref{alg:memb:active_view_maint:update_eval}). This mechanism is only executed if the number of children of a certain node (denoted the ``proposer'') exceeds the configured maximum number of children per parent. In this mechanism, a proposer node proposes to one of its children (denoted node ``A'') a change of parent to another one of its children, (denoted the ``proposed'' node).


When triggered, the proposer node begins by merging all of its received latency pairs into a single set, where the node with the highest capacity is the first node of each pair. While doing so, it discards any new edges which would otherwise lower the overall latency of the system by a larger than configured amount (lines \ref{alg:memb:active_view_maint:update_eval_merge_start}-\ref{alg:memb:active_view_maint:update_eval_merge_finish}). Then, the node iterates the added edges set by ascending order of latency, performing the following verifications:

\begin{enumerate}
    \item If the number of current children minus the nodes already sent to a lower level is lower than the maximum size of a group, then the node concludes the mechanism (line \ref{alg:memb:active_view_maint:check_done_1})
    
    \item If any of the two nodes were already sent to lower levels of the tree, then the current edge is skipped (line \ref{alg:memb:active_view_maint:check_done_2}).
    
    \item Then, if the node with higher capacity of the edge pair has no children yet, the lower capacity node is added to its ``possibleChildren'' set (line \ref{alg:memb:active_view_maint:add_set}). When this set has the same size as the minimum configured group size, then the node issues ``OptimizationPropose'' messages for each node of the set, and removes each child from every other node's potential children (lines \ref{alg:memb:active_view_maint:kick_set_start}-\ref{alg:memb:active_view_maint:kick_set_end}). Alternatively, if the higher capacity node already is a parent (either because some nodes were already chosen to form its group, or because it was already a parent previously), then the coordinator node issues a ``OptimizationPropose'' message to it (line\ref{alg:memb:active_view_maint:kick_already_parent}).
\end{enumerate}

When node ``A'' receives an ``OptimizationPropose'' message with a new proposed parent (line \ref{alg:memb:active_view_maint:opt_propose_recv}), it verifies that the message was sent by its current parent, discarding it if it is not. After this, it sends an ``OptimizationProposeRequest'' message containing itself and the proposer node to the proposed parent, signalling it wishes to become its child. Then, when the proposed parent receives the message (line \ref{alg:memb:active_view_maint:opt_propose_req_recv}), it verifies that the proposer node is still its parent and that node ``A'' is also its sibling, if yes, then it adds the node as its new child and replies with an ``OptimizationProposeRequestReply'', which contains a boolean flag, signalling if the node was added as a child or not. Lastly, when this message is received (line \ref{alg:memb:active_view_maint:opt_propose_req_reply_recv}), the node also verifies that the proposer node is still its parent, aborting the process if it is not, and adds the proposed node as its parent.

After this process is complete, if not aborted, the proposed node becomes the parent of node ``A'', and the proposer node has fewer children, reducing its group size towards the configured maximum (as the proposer node only executes this mechanism if its children number exceeds the configured amount), and when possible, node ``A'' obtains a new node with lower latency than its current latency to the proposer node.

It is important to note that since the mechanism limits the latency downgrade for each new parenthood connection, it does not guarantee that the group sizes are bounded. Although it would be possible to bound the number of nodes per group if this condition were ignored, then the mechanism would conflict with the third mechanism, which we will explain further in the document. \todo{ref to code}

It is important to mention a final mechanism in active maintenance which is ommited from the pseudocode. This mechanism is responsible for ensuring that groups sizes do not become too small, according to a configuration parameter. In sum, every node periodically verifies the number of peers which are its siblings, if this number is lower than a certain threshold, the node ``rolls a dice'' (essentially generates a random number and verifies if it is lower than a certain threshold) to decide if it should abandon the current group. If the generated number is lower than the threshold, the node sends a message to its grandparent asking to become its child. When the grandparent receives the message, it adds the node to its children and sends a message reply, signalling to the original node that it was accepted as a child. It is important to mention that the aforementioned threshold of the ``dice roll'' (and consequently the probability of the node remaining in the current group) decreases quadratically to the difference of the configured group size and the current node's group size.

\subsubsection{Passive view maintenance \& Oportunistic improvement}

The third mechanism of the devised membership algorithm is the passive view maintenance mechanism, it is responsible for creating an auxiliary pool of nodes in the overlay which are not descendants of the executing node. When full, the pool serves two purposes: the first is to enable fault tolerance in the overlay without having to rely on the landmarks, the second is to enable the self-improvement of the overlay. 

There are three components of the Node type (the ID, Coordinates and the version of each node) which were present in the pseudocode of the previous mechanisms, but their explanation was omitted given they are only relevant to the behaviour of the following mechanism. We now explain each in detail, and how it is obtained:

\begin{enumerate}
    \item The ID of each node is a collection of ID segments, where each node's ID is the concatenation of every segment of every ascendant of the node with its own segment. Each node's segment is generated by each parent whenever a new node requests to be its child. An example of a possible ID would be: AAA/BBB/CCC, where the ID segments are: ``AAA'' ,``BBB'' and ``CCC'', this gives each node enough information based on an ID to evaluate if any other node in the overlay is its a descendent, therefore allowing nodes to evaluate if a change of parent in the overlay causes a cycle in the tree. This ID structure also allows nodes check what is the level of any node (the number of segments of the ID is the same as the level of a node in the tree).
    
    \item The coordinates are an array of integers representing the latency every node measured to all landmarks, these coordinates are used as a heuristic for measuring new nodes in the passive view which are potential parents.
    
    \item The version of a node is a monotonic integer which is incremented at every ID change and child addition or removal. This version is used in random walks, to update peers which are currently in the passive view with their new IDs, which prevents nodes from attempting to measure nodes which would be incompatible parents (i.e. they are their descendants, or have no children themselves)
\end{enumerate}

With these concepts explained, we now present the pseudocode (algorithm \ref{alg:memb:passive_view_maint}) for the mechanism. The first lines declare the new necessary state to the mechanism, which is composed of a set of nodes denoting the passive view of the node (line \ref{alg:memb:passive_view_maint:state}). Then, in the following lines we may observe the mechanism for filling the passive view, this is a periodic procedure which triggers the emmision of new random walk messages, triggered at pre-configured intervals (line \ref{alg:memb:passive_view_maint:walk_trig}), the created random walk message contains a random sample of nodes from the passive view and the active view, the original sender's ID, and an integer representing the messages' time-to-live (TTL). This message is then sent to a node that is not a descendant of the sender.

\input{Chapters/membership/pseudocode/membership/memb_oportunistic_improvement.tex}

Whenever this message is received (line \ref{alg:memb:passive_view_maint:walk_rec}), if the message has travelled a certain number of configurable hops, then the receiving node removes a configurable number of nodes from the sample, if the message has not yet travelled the number of hops, the previous step is skipped. Then, the node merges the removed nodes into his passive view, and adds a random sample of nodes from his own passive and active view to the sample (discarding nodes previously in the sample if the configured maximum sample size is exceeded) (lines \ref{alg:memb:passive_view_maint:walk_rec_merge_start}-\ref{alg:memb:passive_view_maint:walk_rec_merge_end}). The intuition behind skipping a certain number of hops before removing nodes from the sample is to promote exchanges of information with nodes further away (in terms of hops) from the original sender. After this, the message TTL is decreased by one and its value is evaluated: if the TTL of the message is higher than 0, then the node forwards the message to a random node from its active view which is not a descendant of the original sender, if there is no such node, or the TTL is zero, then the node sends, via a temporary connection, a ``RandomWalkReply'' message to the original sender of the random walk with the sample (lines \ref{alg:memb:passive_view_maint:walk_rec_send}-\ref{alg:memb:passive_view_maint:walk_rec_send_end}). Whenever a node receives a ``RandomWalkReply'' it merges the received sample with its passive view, excluding all of its descendants and nodes in the active view (lines \ref{alg:memb:passive_view_maint:walk_reply_recv_start}-\ref{alg:memb:passive_view_maint:walk_reply_recv_end}).

As the overlay evolves with time, the passive views of nodes fill with nodes that are not descendants of the node in question, given this, they are suitable for latency optimizations and fault recovery (in case a parent dies). The procedure responsible for evaluating the nodes for latency optimizations (lines \ref{alg:memb:passive_view_maint:eval_nodes}) is also evaluated periodically at pre-configured intervals, in this procedure, the node selects a random sample of nodes and another sample based on the euclidean distance of their coordinates to the measuring nodes' (with configurable maximum size). Each node selected for this sample (candidates) must satisfy the following conditions (lines \ref{alg:memb:passive_view_maint:opt_verification_1} and \ref{alg:memb:passive_view_maint:opt_verification_2}): 

\begin{enumerate}
    \item If the candidate has no children, then it is excluded from the process.
    
    \item If the candidates' level (obtained from the ID) is lower than the measuring nodes', and the measuring node has more than 0 children, then the candidate is excluded (in order to prevent nodes with multiple children from going down in levels and favour instead nodes with no children joining the upper levels of the tree).
\end{enumerate}

After the measurements are issued, whenever a ``peerMeasured'' event is triggered, the node compares the current latency of its parent with the measured nodes' latency: if the latency to the measured node is lower than the current parents' by a configurable threshold, then the measuring node will send an ``OportunisticImprovementReq'' message to the measured node. When it receives this message, it checks that the receiving node is not a descendant of the sender (to prevent the creation of loops in the tree), and replies with an ``OportunisticImprovementReqReply'' message containing a boolean value representing whether the node was accepted as a child, or not.

\subsubsection{Fault tolerance}

Fault tolerance in the protocol is done whenever a parent failure is detected, either due to the PHI-accrual failure detector provided by the Node Watcher (\ref{sec:GO-Babel}) or by failure of a TCP connection which triggers a notification to the protocol. The node first attempts to fall back to its grandparent (provided via the periodic information in \ref{sec:overlay_network:active_view_maint}), then, if this fails, it falls back to any node in its passive view that is not a descendent. Fault recovery is achieved by sending a ``FaultRecovery'' message containing its ID and setting up a timeout timer for each fault recovery attempt. Nodes that do not reply to ``FaultRecovery'' messages within the specified timeout are considered to be failed and removed from the passive view. If the passive view becomes empty, then the node starts the join mechanism again (subsection \ref{sec:overlay_network:join}).

\subsection{Summary}

In this section, we provided a detailed explanation of the behaviour of the membership protocol, we began by explaining how nodes join the network using a greedy depth-first search to find a suitable low latency node in the network with more than zero children. Then, after this low-latency parent is established, we specified the information which is exchanged with it over time, and the parent eploys this information to coordinate with its children in an attempt to maintain the group size within a certain bound, and attempt reduce overall system latency in the process. Lastly, we explained how nodes obtain information about other random nodes in the nertwork, and how that information is used to perform latency optimizations which reduce the total overlay network latency.