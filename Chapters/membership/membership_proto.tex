
\input{Chapters/membership/pseudocode/jlt-pseudocode.tex}

In this section, we discuss the design of the overlay network, which aims to build and maintain a latency and capacity-aware tree-shaped network (capacity represents one, or a combination of, values that denote the node's computing and networking power). We begin by providing the considered system model, then follow with an overview of the mechanisms responsible for building and maintaining the tree. Lastly, we conclude the chapter with a summary and discussion of the protocol.

\subsection{System Model}

The assumed system model is assumed to be a distributed scenario composed of nodes connected to the internet set-up such that they can send and receive messages via the internet (with an external IP or port-forwarding). We also assume that nodes are spread throughout a large area and have varied capacity values.

Regarding the fault model, we assume that all but a small portion of nodes (also known as the landmarks, which in our model represent DCs) can fail, and when other nodes fail, they do so in a crash-fault manner, stopping all emissions and receptions of messages. We assume landmarks have additional fault tolerance given their privileged infrastructure, and additionally, we assume other such as replication \cite{} mechanisms could be employed to ensure that faulty landmarks get replaced in case of failure. 
  
Finally, all nodes must run the same software stack with similar configuration settings and landmark values, installed a priori.

\subsection{Overview}

As previously mentioned, the main objective of the created protocol is to establish a latency and capacity-aware multi-tree-shaped network, rooted on the previously mentioned landmarks. Our motivations for choosing the tree structure for the network are the following: (1) to map the cloud-edge environment, by rooting the trees on nodes running DCs in the cloud, and creating a hierarchical structure for other, less powerful, nodes to be coordinated from the roots \todo{isto e esticar?} (2) to be able to map the heterogeneity of each device in the environment: by biasing the placement of nodes in the tree such that nodes with higher capacity are placed higher in the tree, and nodes with lower capacity are biased towards lower levels of the tree, nodes are used more or less according to their capacity values; (3) the tree structure can be easily employed to perform efficient aggregations, by propagating and merging values recursively from the lower to the higher levels of the tree, which is the basis for the aggregation protocol presented in \todo{add ref}; and finally, (4) by leveraging on the tree structure, nodes can propagate information efficiently, given that, in a network composed of N nodes, broadcasts require only N-1 message transmissions to reach all nodes in the network. 

The tree structure the protocol aims to establish and maintain can be observed in figure \todo{criar imagem para ilustrar estrutura resultante}, which, as previously referenced, is composed of multiple trees, and these are connected through their respective landmarks. The nodes connected to the landmarks, (denoted their \textbf{children}), may or may not form themselves be the parent of their own children. Intuitively, the \textbf{grandparent} of a certain node is their parents' parent, and the descendants of a certain node are constituted by all its children, and childrens' children, recursively. All nodes who share the same parent (\textbf{siblings}) are connected among themselves, forming a \textbf{group}, whose size is biased (but not guaranteed) to be within two configurable upper and lower bounds. Therefore, all nodes have active connections to their parent, children and siblings, this group of nodes denotes a node's \textbf{active view}. Nodes also have have knowledge of other nodes in the network, acquired via periodic semi-random periodic walks, which we will describe ahead. 

The devised algorithm is composed by three main mechanisms: (1) the \textbf{join} mechanism, which aims to establish the initial tree structures, (2) the \textbf{active view maintenance}, responsible for bounding the number of connections for each node, and optimizing the connections of each node, (3)  and finally \textbf{passive view maintenance}, responsible for collecting information about peers which are not in the active view, which are used for both fault tolerance and connection optimizations.

\subsubsection{Join mechanism}

The Join mechanism is the mechanism responsible for choosing the initial parent connection, which performs a greedy depth-first search to find a suitable low latency node in the network with more than zero children. This mechanism is the first to be executed by all nodes in the system, with the pseudocode presented in algorithm \ref{alg:memb:join}. 

\input{Chapters/membership/pseudocode/membership/memb_join-small.tex}

Its first step (line \ref{alg:memb:join:state}) is to initialize the state of the joining node, composed by: (1) a map of type Node containing all successfully contacted nodes so far the join process, (2) a collection of type Node and a set of timer ids for each contacted node, (4) the best node contacted so far in the join process, (5) a timer id for contacting the chosen node in the join process, and finally (5) a variable of type Node denoting the peer itself. The type ``Node'' is a collection of attributes regarding a node, composed of latency measured, its current parent, number of children, whether the node replied to the message, its IP, and an array of its childrens' IP and children number.

Then, each node joins the system, the procedures taken to join the tree differ consonant the node is a landmark or not. Given that landmarks are the roots of the trees, they have no parent in the resulting overlay, and consequently, in the join algorithm, these nodes attempt to repeatedly establish a connection with other landmarks by sending a special message. Landmarks that receive this message will send a reply and establish a connection back (line \ref{alg:memb:join:add_land}), a joining landmark node only stops sending messages to other landmarks when the respective reply is received.

Nodes that are not landmarks begin the process of choosing their initial parent, initiated by sending a JOIN message via a temporary TCP channel, measuring the latency, and issuing ``joinTimers'' for all tree roots (line \ref{alg:memb:join:contact_landm}), then the node awaits the responses from the contacted nodes, during this process, the joining node listens for any ``joinTimers'' which have triggered, or until any of the node measurements has been unsuccessful (meaning contacted nodes have exceeded their reply timeout), if this happens, in the case of the contacted node being a landmark, the joining node aborts the join process and waits a configurable amount of time until attempting to re-join the overlay again. If the timed-out node is not a landmark, then that node is excluded from the remaining of the join process, and the join process is resumed as normal (line \ref{alg:memb:join:exclusions}).

When a node receives a JOIN message, it sends a JOINREPLY message back to the original sender containing: its parent, itself, and its children (line \ref{alg:memb:join:recv_join}). When the joining node receives the joinReply, it checks to see if it is not from a timed out node, or if the node's parent is not the same anymore, if any of these conditions are observed, then the reply is discarded. 

Then, whenever the joining node has either: received the JOINREPLY messages from all the contacted nodes, and stored the information (line \ref{alg:memb:join:recv_join_reply}), or they have been timed-out via the ``joinTimers'', it evaluates all contacted nodes, attempting to find the contacted node with the lowest latency which is a suitable parent by performing the following verifications:

\begin{enumerate}
    \item Verify if the node already has any children or if the node is a landmark (and can become parent of the joining node) (line \ref{alg:memb:join:verif_children}).
    
    \item Verify if there was a node already contacted which was a suitable parent and had lower latency, if there was, the joining node sends a JOINREQUEST and sets up a ``JoinRequestTimer'' for that node, and stops the verification process. (line \ref{alg:memb:join:verif_vs_prev})

    \item Verify if the current node has both enough children, and has the lowest latency up to this point in the join process, then the joining node assigns it as its best node so far and starts a new recursive step by sending JOIN messages and measuring the children of that node which themselves have more than one children (line \ref{alg:memb:join:advance}). Note that if none the current nodes' children are suitable parents (i.e. have no children themselves), then the condition in line \ref{alg:memb:join:cond_go} is triggered and the joining node will request the current best node to be its parent.
\end{enumerate}

If none of the verified peers was suitable to start a new recursive step (line \ref{alg:memb:join:join_base_case}) (either had no children or all verified nodes had higher latency than a previously contacted node), then the node joining node sends a ``JoinRequest'' to that node and sets up a ``JoinRequestTimer'' for the best previously contacted node (any node which receives a ``JoinRequest'' message replies with a ``JoinRequestReply''). 

The join process is concluded with both the reception of a ``JoinRequestReply'' and the establishment of the connection between the sender and receiver of the message. If the ``JoinRequestTimer'' timer triggers while waiting for the response, the node will recursively fall back to the parent of the selected node or re-join the overlay later in case there is no parent available. 

\subsubsection{Active view maintenance}

The second mechanism of the devised membership algorithm, called active view maintenance, is the mechanism responsible for maintaining the size of the groups. It achieves this by choosing new parents to form new groups using latency and node capacity as heuristics for the choice. This mechanism is coordinated by each parent, and is only done when the group exceeds its size limit. The information necessary to feed this mechanism is transmitted periodically from each children to their parents. 

The pseudocode for this mechanism is presentend in algorithm \ref{alg:memb:active_view_maint}, and starts by defining the necessary state: the nodes' active view (parent, children, and siblings), and an auxiliary map of sets, which holds the latencies of each children to every other children. (lines \ref{alg:memb:active_view_maint:state_start}-\ref{alg:memb:active_view_maint:state_end}). 

The mechanism starts with the propagation of information from the parent to the children and vice-versa. As observable in lines \ref{alg:memb:active_view_maint:update}-\ref{alg:memb:active_view_maint:update_end}), each parent transmits to its children a list of its current siblings, and propagates to its parent the latency to each of its siblings. Then, when this information is received (lines \ref{alg:memb:active_view_maint:update_recv_par} and \ref{alg:memb:active_view_maint:update_recv_chi}), it is merged into their local states for later use.

The second part of this mechanism is also periodic and is responsible for maintaining the group sizes by creating new groups, or sending children to already created groups (line \ref{alg:memb:active_view_maint:update_eval}) when necessary, this mechanism is only executed if the number of children exceeds the configured maximum number of children per parent (in order to keep group sizes close to full). Each node starts by merging all of its received latency pairs into a single set, where the node with the highest capacity is the first node of each pair (lines \ref{alg:memb:active_view_maint:update_eval_merge_start}-\ref{alg:memb:active_view_maint:update_eval_merge_finish}). Then, it iterates the added edges set by ascending order of latency, making the following steps:

\begin{enumerate}
    \item If the number of current children minus the nodes already sent to a lower level is lower than the middle point between the maximum size of a group, then the node concludes the mechanism (line \ref{alg:memb:active_view_maint:check_done_1})
    
    \item if the latency of the node pair that is being observed is higher than the parents latency to it, meaning it raises the overall latency of the system, and the current node size is lower than the configured maximum, then the process is concluded. (line \ref{alg:memb:active_view_maint:check_done_2})
    
    \item If any of the nodes was already sent to lower levels of the tree, then the current edge is skipped (line \ref{alg:memb:active_view_maint:check_done_3})
    
    \item Then, if the node wigh higher capacity of the edge pair has no children yet, the lower capacity node is added to its ``possibleChildren'' set, when this set has the same size of the minimum configured group size (i.e. the hifgher capacity node has enough candidates to form a new group), then the 
\end{enumerate}


\input{Chapters/membership/pseudocode/membership/memb_active_view_maintenance.tex}


\subsubsection{Passive view maintenance}
\input{Chapters/membership/pseudocode/membership/memb_oportunistic_improvement.tex}

\subsection{Summary}

\section{Monitoring protocol}

\subsection{Overview}

\subsection{Aggregation mechanisms}

\subsubsection{Single root aggregation}

\subsubsection{Multi root aggregation}

\subsubsection{Neighborhood aggregation}

\subsection{Summary}

\section{API}

\subsection{System Model}

\subsection{Overview}

\subsection{Showcase}