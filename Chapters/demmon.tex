%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter2.tex
%% NOVA thesis document file
%%
%% Chapter with the template manual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE demmon.tex}

\chapter{DeMMON}
\label{cha:demmon} 

DeMMon (Decentralized Management and Aggregation Overlay Network) is a monitoring framework which aims to tackle the needs of decentralized resource management tools. These tools, as previously mentioned, must perform resource management decisions, such as load balancing or QOS optimizations, supported by partial and localized knowledge of the system. It is the goal of this framework, through the on-demand decentralized collection, aggregation and storage of metrics in the form of time-series, to provide this knowledge base. We now detail what we believe to be the most common requirements of such tools:

\begin{enumerate} \label{enum:demmon}

    \item \textbf{Have a partial set of nodes} from the system which are nearby (according to a certain proximity heuristic). These nodes are crucial in order to perform the aforementioned localized resource management decisions. In our framework, we chose latency as the heuristic for the proximity heuristic as not only does it does not rely on external tools, such as traceroute or a reverse IP-to-geolocation service, nor does it require pre-configuration of geolocation, making it possible for all nodes' configurations to be similar (thus making the deployment of large quantities of nodes easier). \label{enum:demmon_1}
    
    \item Ensure there are ways to \textbf{obtain the aggregate value of a metric distributed across the entire system} (e.g. the total number of nodes, service replicas, among others) without having to rely on a central component. This feature is crucial for resource management tools so they, for example, maintain a desired ratio of service replicas to nodes: by simultaneously collecting both the number of nodes in the system and the number of replicas, nodes can perform local decisions such as creating or decomissioning replicas, whenever the desired ratio of reaches a certain bound. \label{enum:demmon_2}
    
    \item Having a way to perform \textbf{decentralized collection of metrics from "nearby" nodes}. This feature is useful for decentralized resource management systems as it allows nodes to perform actions such as load-balancing or QOS improvement: by collecting the metrics relative to the usage of nearby nodes, each node may decide (e.g to perform latency, or reduce the load on a saturated service) to perform service migration or service replication. \label{enum:demmon_3}
    
    \item As it is impossible to know ahead of time what information such systems would otherwise require, it is also a requirement to \textbf{be as flexible as possible in regard to the types of metrics} that are stored. This is paramount as resource management tools may need to store information in custom formats, tailored for their own needs. \label{enum:demmon_4}
    
    \item Provide ways to efficiently \textbf{propagate information} accross nodes in the system. This is useful for resource management systems, as it allow them to disseminate information using the optimized connections established by the framework. \label{enum:demmon_5}
    
    \item Ensure ways to \textbf{receive alerts} based on the collected information without resorting to periodically requesting/consulting it. By setting these alarms, resource management tools can, in turn, trigger resource management actions, for example, setting an alarm if the mean of the CPU usage over the last N seconds reaches a certain threshold, individual nodes may perform load-balancing actions. \label{enum:demmon_6}
    
\end{enumerate}

Having enumerated what we believe to be the requirements of such tools, we now provide a brief overview of the devised framework which aims to fulfil these requirements. 

\section{Framework overview}
\label{sec:framework_overview}


The devised framework, (ilustrated in figure \ref{fig:demmon-overview}), is composed of four main modules, the overlay network, the aggregation protocol, the API, and the monitoring module. We now describe each module's role within the framework and how they contribute to fulfil the aforementioned requirements.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Chapters/Figures/DeMMon-arch-overview.pdf}
    \caption{An overview of the architecture of DeMMon}
    \label{fig:demmon-overview}
\end{figure}
    
First, the \textbf{API} exposes the functionality of the framework, its main objectives are to: (1) allow issuing commands to collect metrics about nodes (or services they host) in the system; (2) allow those metrics to be queried through the use of a query language; (3) allow registering alarms which trigger based on conditions which evaluate the collected information. It is important to notice that the API is not the component tasked with gathering the information to perform these tasks, instead, the API's purpose is to expose the results and mediate the interactions between the clients and the remaining modules.

Second, the \textbf{monitoring module} which is tasked with storing metrics, resolving queries regarding stored metrics, removing expired metrics, and periodically evaluating registered alarms and triggering callbacks which the API then propagates to the client. This module, toghether with the API, satisfies points (\ref{enum:demmon_4} and \ref{enum:demmon_6}) of the aforementioned requirements.

The \textbf{overlay network} strives to build a latency-aware multi-tree-shaped network. Nodes in this network use latency, node capacity, and a set of logical rules to change their location either from one tree to another or within their tree until they have an optimized set of nodes (according to latency). The connections resulting from the operation of this protocol are the basis for the aggregation protocol. In addition, this module also offers limited horizont flood techniques, exposed through the API, fulfilling the points \ref{enum:demmon_1} and \ref{enum:demmon_5} of the requirements.

Finally, the \textbf{aggregation protocol} is a component that performs on-demand metric collection based on issued commands from the API. This component takes advantage of the overlay networks' established connections and hierarchical structure to perform efficient distributed aggregations. It allows three types of decentralized aggregation: (1) tree aggregation, which consists of collecting metrics and merging them using the tree, collecting a globally aggregated value in the tree roots, or a partial view of the system for nodes which are not the root of the overlay); (2) global aggregation, where nodes also use their tree connections to efficiently collect an aggregated global value (independently of being the root of the tree); and (3) neighborhood aggregation, where nodes collect values (non aggregated) of nearby nodes in term of hop proximity. These three mechanisms satisfy points \ref{enum:demmon_2} and \ref{enum:demmon_3} of the aforementioned requirements. 

In the following sections we will provide a detailed explanation of each individual module, starting by the \textbf{overlay network} (section \ref{sec:overlay_network}), followed by \textbf{aggregation protocol} (section \ref{sec:mon_protocol}), and lastly, the \textbf{monitoring module} (section \ref{sec:mon_module}) and \textbf{API} (section \ref{sec:api}). 

\section{Overlay network} 
\label{sec:overlay_network}
\input{Chapters/membership/membership_proto.tex}

\section{Aggregation protocol}
\label{sec:mon_protocol}
\input{Chapters/aggregation/aggregation_proto.tex}

\section{Monitoring module}
\label{sec:mon_module}
\input{Chapters/api/api.tex}

\section{API}
\label{sec:api}
\input{Chapters/api/api.tex}

\section{Showcase}


% .
% It is important to notice that, as the nodes are organized in a tree, resource management systems may also take advantage of this structure to perform actions more efficiently, for example, using 

% such that nodes in higher levels of the tree have a broader knowledge of the whole system, and nodes in lower levels have more localized information. This feature is especially useful for frameworks that take advantage of the hierarchical structure to organize its nodes.

