\begin{algorithm}
    % \setstretch{0.85}
    \begin{algorithmic}[1]

        \caption{Active view Optimization}

        \asdstate
        \State childrenLatencies : dict<string:dict<string:number>>
        \asdend

        \asdrepeateveryx{config.updateChildPeriodicity}
        \If{parent != nil}
        \State sLatencies = set()
        \For{sibling in siblings}
        \State sLatencies.append(<sibling.IP,sibling.measuredLatency)
        \EndFor
        \State sendMessage(UpdateChildStatus<children, siblingLatencies>, parent)
        \EndIf
        \asdend

        \asdrepeateveryx{config.updateParentPeriodicity}
        \For{child in chidren}
        \State sendMessage(UpdateParentStatus<self,child.ID, parent>)
        \EndFor
        \asdend

        \asdupon[receive(UpdateParentStatus<parent,myID, grandParent>, sender)]
        \If{sender == parent.IP}
        \State parent = parent
        \State self.ID = parent.ID + myID
        \State grandParent = grandParent
        \EndIf
        \asdend

        \asdupon[receive(UpdateChildStatus<child, childSiblingLatencies>, sender)]
        \If{children[sender] != nil}
        \State children[sender] = children
        \State childrenLatencies[sender]=childSiblingLatencies
        \EndIf
        \asdend

        \asdrepeateveryx{config.updateChildPeriodicity}
        \State childrenLatValues = set()
        \For{c1 in children}
        \For{<c2, lat> in childrenLatencies[c]}
        \If{lat - c1.measuredLatency >= d.config.maxLatDowngrade}
        \State break
        \EndIf
        \State higherBwC = c1
        \State lowerBWC = c2
        \If{c2.bw > c1.bw}
        \State higherBwC = c2
        \State lowerBWC = c1
        \EndIf
        \State childrenLatValues.add(<higherBwC,lowerBWC,lat>)
        \EndFor
        \EndFor
        \State kickedNodes = set()
        \State newParents = set()
        \State potentialChildren = dict<string,set<Node>>
        \State sortByLatency(childrenLatValues)

        \For{<higherBwC,lowerBWC,lat> in childrenLatValues}
        \If{len(children) - len(kickedNodes) <= config.MinGroupSize}
        \State break
        \EndIf
        \If{higherBwC in kickedNodes or lowerBWC in kickedNodes}
        \State continue
        \EndIf
        \If{loserBWC in newParents}
        \State continue
        \EndIf
        \If{higherBwNode.nrChildren == 0}
        \State potentialChildren[higherBwNode].append(lowerBWC)
        \If{len(potentialChildren) >= config.MinGroupSize}
        \For{potentialChild in potentialChildren[higherBwNode]}
        \State newParents <- newParents + higherBwNode
        \State send(OptimizationPropose<higherBwNode>, potentialChild)
        \State higherBwNode.nrChildren++
        \State kickedNodes <- kickedNodes + potentialChild
        \EndFor
        \For{<nIP,potentialChilren> in potentialChildren}
        \State potentialChilren.deleteAll(potentialChildren[higherBwNode])
        \EndFor
        \State potentialChildren[higherBwNode] = set<Node>
        \State continue
        \EndIf
        \EndIf
        \State kickedNodes <- kickedNodes + lowerBWC
        \State send(OptimizationPropose<higherBwNode>, lowerBWNode)
        \EndFor
        \asdend

        \asdupon[receive(OptimizationPropose<newParent>, sender)]
        \If{sender == parent}
        \State send(OptimizationProposeRequest<sender>, newParent)
        \EndIf
        \asdend

        \asdupon[receive(OptimizationProposeRequest<p>, sender)]
        \If{ p == parent \&\& sender in siblings} \Comment{ parent issuing the message is the same parent that i have}
        \State send(OptimizationProposeRequestReply<true>, sender)
        \Else
        \State sendSideChannel(OptimizationProposeRequestReply<false>, sender)
        \EndIf
        \asdend

        \asdupon[receive(OptimizationProposeRequestReply<reply>, sender)]
        \If{reply}
        \State sendMessageAndDisconnectFrom(DisconnectMessage<>, parent)
        \State addParent(sender)
        \EndIf
        \asdend

    \end{algorithmic}
\end{algorithm}