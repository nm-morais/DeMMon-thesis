
With a membership protocol capable of coordinating nodes into building a tree overlay network, a new range of options open for both the dissemination and aggregation of information. In this section, we discuss the devised decentralized aggregation protocol, which leverages on the tree structure to enable the on-demand collection of information (or metrics) in a decentralized manner. While in this work we present the protocol leveraging the overlay protocol defined in \ref{sec:overlay_network}, it is important to notice that the protocol is agnostic to which overlay protocol is executing, as long as it has the following characteristics: (1) it forms one or more network-shaped trees whose roots are interconnected, nodes in this tree must be connected to their parents, children and siblings (active view) in a bidirectional manner, and must provide callbacks for each node that is added or removed from the nodes's active view.

This protocol provides three different types of decentralized aggregation techniques, inspired from the study of the state of the art: (1) tree aggregation, (2) neighbourhood aggregation, and finally, (3) global aggregation, which we now clarify in further detail, starting by tree aggregation.

\subsection{Tree aggregation} \label{sec:mon_protocol:tree_agg}

Tree aggregation is the mechanism responsible for collecting metrics and merging them using the tree, collecting an aggregated value for all nodes which are descendants of the node performing this mechanism (also denoted the \textbf{root of the aggregation tree}). It is important to notice that this mechanism is executable by all nodes in the mechanism, and if two different nodes are aggregating the same values with the same parameters, and a node is descendent of the other, the descendant node, will, when possible, embed its tree into the ascendants' (thus not performing the mechanism individually for nodes with overlapping trees, and reusing the values of the already existing tree).

The pseudocode for this mechanism (as defined in \ref{alg:mon:tree_agg}) begins by defining the necessary state (line \ref{alg:mon:tree_agg:state}) for its execution, starting by the active view, composed of the parent, children, and siblings of the node, this state is maintained by the overlay protocol and changes to it are propagated through notifications (this process is omitted from the pseudocode). Then, it declares three maps, the first contains the necessary metadata for each aggregation tree, values of this map contain: (1) the height of the tree, (2) the merge function, (3) the query to generate local values, (4) the periodicity to export values (5) a boolean value representing if the value should be exported locally, (6) a boolean representing if the parent is also in the tree (and the node must propagate values to it or not), and finally (7) the ID of the tree from the parent's perspective (or nil, if the parent is not in the tree).

\input{Chapters/aggregation/pseudocode/tree_aggregation.tex}

Tree aggregation is started by the API sending a request to the protocol signalling the node should begin the procedure (line \ref{alg:mon:tree_agg:start_req}), this request contains: the maximum height of the tree, the merge function, the query to obtain the local value, the periodicity to execute the mechanism, and lastly, the resulting metric name. When a node receives this request, it generates a tree ID by hashing the concatenation of the tree height, the merge function, the query, the mechanism periodicity and finally the resulting metric name. This hashing is done so aggregation trees with different roots are embedded into each another, for example, if a certain node wishes to create an aggregation tree with height 5 rooted on itself, then, if a children of his (1 level lower) also creates an aggregation tree with height 4, the two trees will be embedded (as their ids will match), meaning the parent's aggregation results will be used to feed the locally requested values. It is important to notice that if the tree height is -1, then it is treated as if it had infinite height.

Before adding the tree to its local tree map, the node checks if there already is a tree with the same ID (meaning it has the same tree height, merge function, query, periodicity and resulting metric name) in the ``tIds'' map, if there is, then it sets the flag signalling the value should be exported locally, otherwise it adds a new entry to the map and sets up a periodic timer for that aggregation tree (lines \ref{alg:mon:tree_agg:start_req_start} to \ref{alg:mon:tree_agg:start_req_end}).

Whenever this timer triggers, (line \ref{alg:mon:tree_agg:export_trigger}), the node checks if the aggregation tree has expired (i.e. if the parent stopped refreshing the aggregation tree), if it it has, then the node cancels the timer and deletes the tree metadata, if it has not expired, then the node evaluates the query (this procedure will be explained in section \ref{sec:mon_module}), obtaining its local value, then it merges all the values sent by its children with its own using the merge function, producing the final aggregated result. Afterwards, if configured to do so, it will store the value locally, and if the parent is also subscribed to the aggregation tree, it propagates the obtained value to it. Whenever a node receives this propagation of values from another node (line \ref{alg:mon:tree_agg:recv_propag_vals}), it checks that it has the corresponding aggregation tree in its local set of trees and that the message was sent by its children, discarding it if it is not, and stores the received values into a map of maps, containing all children values for each aggregation tree.

Finally, each node periodically (using configured intervals) broadcasts to its children a message containing the aggregation trees it is the root of and that have height higher than 0 (line \ref{alg:mon:tree_agg:propag}). Whenever this message is received (line \ref{alg:mon:tree_agg:propag_recv}), the child merges all the received aggregation trees with registered ones, marking the parent as a subscriber for each previously present tree, and propagates the aggregation trees from which he is not the root of to its children.

\todo{talvez meter uma conclus√£o aqui?}

\subsection{Neighborhood aggregation}

Neighborhood aggregation is the mechanism responsible for collecting metrics from neighboring nodes to the node performing this mechanism, in essence, every node executing this mechanism creates a tree rooted upon itself by broadcasting messages with a configurable hop-based range periodically. Then, nodes who receive that message (essentially becoming federated in the tree) rebroadcast it to other peers and start to periodically propagate these values towards the root of each tree using the reverse path established by the broadcast message. Nodes in overlapping trees (i.e. propagating values derived from the same query) deduplicate the mechanisms of the propagation of broadcast messages and metric emission (by employing hashing, similarly to \ref{sec:mon_protocol:tree_agg}) in order to reduce the number of propagated messages.



\subsection{Global aggregation}

\subsection{Summary}
