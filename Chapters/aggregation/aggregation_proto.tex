
Provided with a membership protocol capable of coordinating nodes into building an efficient tree structure, in this section, we now discuss how we leveraged on it to provide efficient abstractions for performing aggregation/collection of metrics about the execution of nodes (or services) executing in the system in a decentralized manner. The three primitives provided are the following: (1) tree aggregation, (2) neighbourhood aggregation, and finally, (3) global aggregation, which we now clarify in further detail, starting with tree aggregation.

It is important to mention that while in this work we present the protocol leveraging the overlay protocol defined in \ref{sec:overlay_network}, the protocol is agnostic to which overlay protocol is executing underneath it, as long as it has the following characteristics: (1) it forms one or more tree-shaped networks, whose roots are interconnected. Nodes in these trees must be connected to their parents, children and siblings (also denoted by their active view) in a bidirectional manner. The overlay protocol must also provide events for each node that is added or removed from the nodes' active view.

\subsection{Tree aggregation} \label{sec:mon_protocol:tree_agg}

Tree aggregation is the mechanism responsible for collecting metrics and merging them using the tree, collecting an aggregated value for all nodes which are descendants of the node performing this mechanism (also denoted the \textbf{root of the aggregation tree}). This mechanism is executable by all nodes in the mechanism, and if two different nodes are aggregating the same values with the same parameters, and a node is descendent of the other, then the descendant node will (when possible) reuse the values of the already existing tree by embedding its tree into the ascendants'.

The pseudocode for this mechanism (defined in \ref{alg:mon:tree_agg}) begins by defining the necessary state to execute the aggregation mechanism (line \ref{alg:mon:tree_agg:state}), starting by the active view, composed by: the parent, children, and siblings of the node (maintained by the overlay protocol with changes to it propagated through notifications). In addition, the state also contains three maps, the first map, called ``tIds'' containing the necessary metadata for each aggregation tree, each value of this map is composed by: (1) the height of the tree, (2) the merge function, (3) the query to generate local values, (4) the periodicity to export values, (5) the output metric name, (6) the ID of the corresponding timer, (5) a boolean value representing if the value should be exported locally, (6) a boolean representing if the parent is also in the tree (and the node must propagate values to it or not), and finally (7) the ID of the tree from the parent's perspective (or nil, if the parent is not in the tree). The second map denominated ``lastSeen'', contains a Timestamp for each tree, representing the last time the parent sent a message for that tree, and finally, the ``childValues'' map which contains, for each tree, the values emitted by the children and the timestamp of their reception.

\input{Chapters/aggregation/pseudocode/tree_aggregation.tex}

Nodes begin executing this mechanism when the API sends a request to the protocol (line \ref{alg:mon:tree_agg:start_req}), which contains the maximum height of the tree, the merge function, the query to obtain the local value, the periodicity to execute the mechanism, and the resulting metric name. Upon the reception of this request, the node creates the ID for the aggregation tree by hashing the concatenation of the tree height, the merge function, the query, the mechanism periodicity and the resulting metric name, guaranteeing that aggregation trees with the same height (from the hashing nodes' perspective) have the same ID. Whenever two trees have the same ID, the node that detects this may reuse the already existing tree's aggregation results, not increasing the necessary messages to collect the metric values for an additional node. After this, the node receiving the request adds the tree to its local aggregation ``tIds'' map, first checking if it is already federated to a tree with the same ID, meaning it may reuse the existing tree for obtaining the requested values). If there is, then it sets a flag signalling it should also save the values locally to true. Otherwise, it adds a new entry to the ``tIds'' map and sets up a periodic timer for that aggregation tree (lines \ref{alg:mon:tree_agg:start_req_start} to \ref{alg:mon:tree_agg:start_req_end}).

In order to federate all nodes into their trees, nodes periodically (using configured intervals) broadcast to their children a ``Subscription'' message containing the aggregation trees they are the root of (line \ref{alg:mon:tree_agg:propag}). Whenever this message is received (line \ref{alg:mon:tree_agg:propag_recv}), for each received ID, if it was previously present in the ``tIds'' map, the child marks the parent as a subscriber and refreshes the timeStamp associated with the tree in the ``LastSeen'' map. Conversely, for each received aggregation tree that was not previously in the ``tIds'' map, it sets a new periodic timer called ``ExportTreeAggTimer'', and adds the ID to the ``tIds'' map. Lastly, the node subtracts by one each of the received tree TTLs and sends a ``Subscription'' containing the ones with TTL higher than zero (or equal to -1) to its children. This means that if a tree has a single root node, and that node crashes or stops propagating ``Subscription'' messages, all other nodes belonging to that tree will not send more ``Subscription'' messages.

Whenever the aforementioned periodic timer called ``ExportTreeAggTimer'' triggers, (line \ref{alg:mon:tree_agg:export_trigger}), the node checks if the respective aggregation tree has expired (i.e. if the parent stopped refreshing the aggregation tree), if it has, and the node is not a root of the tree, then it cancels the timer and deletes any related tree metadata, if the node is a root of the tree, it sets the flag representing wether the node should propagate to the parent as ``false''. If the tree has not expired, the node evaluates the query (this procedure will be explained in further detail in section \ref{sec:mon_module}), obtaining its local value and merging it (using the supplied aggregation function) with all the values sent by its children, producing the final aggregated result (before merging the values, the node excludes all values with a timestamp older than a configurable duration). Afterwards, if configured to do so, it will store the value locally, and if the flag signalling it should propagate to the parent has the value ``true'', it sends a message to the parent containing the obtained value. Upon the reception of this message by the parent, (line \ref{alg:mon:tree_agg:recv_propag_vals}), it verifies if it has the corresponding aggregation tree in its local ``tIds'' map, discarding the message if it is not present, and finally, stores the received value into the ``childValues'' map.

Although it is omitted from the pseudocode, it is important to mention that for nodes that are roots of the aggregation trees, it is also possible (according to a configuration parameter) to store the neighbours' values locally (without merging with the local or any other neighbours' values). This feature is useful for applications as it provides them with a sense of directionality. For example, if an application needed to deploy service replicas according to geographical proximity to a certain target, this feature can be useful for obtaining an average of latitudes and longitudes for all nodes ``behind'' a certain node in the active view. Then, an application may recursively send messages to nodes in the immediate view that approximate a certain geographical target. \todo{maybe imagem?}

\todo{talvez meter uma conclusão aqui?}

\subsection{Neighborhood aggregation} \label{sec:mon_protocol:neigh_agg}

Neighbourhood aggregation is the mechanism responsible for collecting metrics from neighbouring nodes, this feature is useful in resource management scenarios such as: whenever a certain node needs to perform service replication/migration, it may collect metrics related to the capacity and usage of nearby nodes (in terms of hop distance) and evaluate which peer is the best candidate before performing such actions. 

In essence, this mechanism behaves similarly to a Pub-Sub system, where nodes create an aggregation trees rooted upon themselves by broadcasting ``Subscription'' messages periodically with a configurable hop-based range (or TTL).  Nodes that receive this message become federated in the tree, and rebroadcast it (up to the configured TTL) to other peers, federating all nodes in the configured hop-range. Afterwards, for each tree, all federated nodes periodically propagate their locally obtained values towards the root of each tree using the reverse path established by the broadcast message. 

Trees have associated IDs, generated using hashing in a similar manner to the tree algorithm defined in \ref{sec:mon_protocol:tree_agg} (without using the level in the hash process), and consequently, all nodes collecting the same metric using this mechanism will have trees with equal IDs. Nodes belonging to overlapping trees (i.e. in the range of two different nodes collecting values in this manner), only generate values periodically for one of the trees and propagate the generated value towards the direction of the multiple tree roots, in order to prevent unnecessary query evaluations. In addition, nodes in overlapping trees, when possible, also deduplicate ``Subscription'' messages.

This mechanism, similarly to Tree Aggregation (subsection \ref{sec:mon_protocol:tree_agg}), is triggered via a request from the API, containing, among other parameters, the query to obtain the local values, the hop range, and the target periodicity to collect the values. The receiver of the request (denoted the \textbf{root of the aggregation tree} (illustrated by node A in figure \ref{sec:mon_protocol:img:neigh_agg_sub}) creates the ID for that aggregation tree by hashing a combination of the metric name and the periodicity. This process makes nodes with equal parameters have equal IDs and become federated to the same tree. After the ID generation, the node begins propagating periodically a ``Subscription'' message to its immediate neighbours (illustrated in step 2 of figure \ref{sec:mon_protocol:img:neigh_agg_sub}) containing the ID of the tree, the TTL, the query to obtain their local values, and the mechanism periodicity. 

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Chapters/aggregation/images/neigh-agg-subscribe.pdf}
    \caption{Neighborhood aggregation subscription process (TTL=2)}
    \label{sec:mon_protocol:img:neigh_agg_sub}
\end{figure}
     
Whenever a node receives the ``Subscription'' message, it performs the following steps:

\begin{enumerate} \label{sec:mon_protocol:enum:neigh_agg_sub_opts}
    \item Verifies the message came from a node contained in the active view, if it did not, the message is discarded.
    \item Stores, for that sender, the ID of the tree, the TTL of the message and a timestamp of the current time. If there is already such an entry, then the timestamp is refreshed.
    \item Decreases the TTL of the message by one
    \item If the message TTL is 0, the node returns from the procedure.
    \item Following, the node performs the following steps to decide where to broadcast to:
            \begin{enumerate}
                \item If the message came from a parent or a sibling, the node broadcasts the message to its children.
                \item If it came from a child, then the node broadcasts the message to the parent and siblings.
                \item Before broadcasting to any node, the sender verifies if it has sent a ``Subscription'' message with a higher or equal TTL than the TTL received to these nodes in the last (configurable) duration. If it has, the sender skips the broadcast for that node.
            \end{enumerate}
\end{enumerate}

With this, in case two different nodes in the system are collecting the same metrics on the same periodicity, the ``Subscription'' messages are not sent unnecessarily to nodes already subscribed to that tree, because whenever the second ``Subscription'' message arrives, it is not broadcasted unless a certain amount of time has passed. This process is illustrated by node A in figure \ref{sec:mon_protocol:img:neigh_agg_second_sub}, where node A receives the Subscribe message and does not propagate it to its siblings nor parent, as it is already federated to the tree (rooted on itself with TTL= 2) and has sent a ``Subscription'' message to its siblings and parent in the previous step.

After nodes become federated in trees, they begin to periodically evaluate the supplied query and obtain their local metric values (storing them locally if they are a root of that tree). When a node obtains its local metric value, it propagates a message containing the metric value and a hop counter to every other node in its active view that has sent a ``Subscription'' message within a configurable time frame. This process is illustrated on pictures \ref{sec:mon_protocol:enum:neigh_agg_sub_opts} \ref{sec:mon_protocol:enum:neigh_agg_sub_opts} and \ref{sec:mon_protocol:enum:neigh_agg_sub_opts}). Nodes that receive this message increment their hop counter and forward it to each other node in its active view that has sent a ``Subscription'' message with a TTL higher or equal to the hop count within a (configurable) time frame.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Chapters/aggregation/images/2nd_subscribe.pdf}
    \caption{Neighborhood aggregation second subscribe (TTL=2)}
    \label{sec:mon_protocol:img:neigh_agg_second_sub}
\end{figure}


\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Chapters/aggregation/images/unsubscribe_process.pdf}
    \caption{Neighborhood unsubscribe (TTL=2)}
    \label{sec:mon_protocol:img:neigh_agg_unsub}
\end{figure}
    
Lastly, nodes periodically verify, for each tree, the time passed since the reception of the last ``Subscribe'' message and remove the ones received after more than a (configurable) amount of time. When nodes remove the expired entry, if there is no other entry for that tree ID, they also stop propagating metric values related to that tree (illustrated in fig. \ref{sec:mon_protocol:img:neigh_agg_unsub}).

\todo{completar com summary}

\subsection{Global aggregation} \label{sec:mon_protocol:global_agg}

Global aggregation is the mechanism executed whenever a certain node wishes (via requests from the API) to obtain a summarized global view of the system (e.g. the total number of nodes in the system). This process, similarly to \ref{sec:mon_protocol:tree_agg} and \ref{sec:mon_protocol:neigh_agg}, is based on federating nodes of the system into \textbf{aggregation trees}, nodes federated in these trees who are not the roots are denoted \textbf{aggregator} nodes, as their role is to collect their neighbours' metric values, aggregate them, and send them toward the root of the tree.

In global aggregation, all nodes participate in all trees, either as a root (if they wish to collect the globally aggregated value), or alternatively as aggregator nodes. In this mechanism, if a tree has multiple root nodes, then the metric values are reused (when possible) from the first tree root towards the other roots and tree maintenance mechanisms of the aggregator trees are deduplicated. 

This mechanism is inspired in the work from \todo{citar akos}, which employs an aggregation technique that leverages a tree-shaped overlay to allow the computation of a globally aggregated value in a decentralized and efficient manner by every node in the system. This is achieved via every node periodically broadcasting to every neighbouring peer their locally aggregated value minus each neighour's contribution, and merging all received contributions with the locally generated one, the continuous exeution of this procedure results in all nodes obtaining the global aggregated value without resorting to aggregating the values toward a single node in the system.

In this mechanism, we leverage the same aggregation technique to collect globally aggregated values in multiple (but not necessarily all) nodes of the system in a decentralized manner. However, unlike the original work, instead of only performing aggregation of a single metric value, we generalize the approach to allow the on-demand creation and teardown of multiple trees, potentially rooted in multiple nodes, with all roots collecting the globally aggregated value. The relaxation of these constraints creates additional challenges regarding the transmission of redundant messages (i.e. to maintain the aggregation tree), which we attempt to mitigate in this work. It is important to mention that, in a scenario where all nodes of the system are roots of the aggregation system, this mechanism behaves similarly to \todo{citar akos}, with the only difference being of allowing the on-demand start and decommission of the aggregation process.

\input{Chapters/aggregation/pseudocode/global_aggregation.tex}

The state necessary for the execution of this mechanism (defined in alg. \ref{alg:mon:global_agg} lines \ref{alg:mon:global_agg:state_start} to \ref{alg:mon:global_agg:state_end}) starts with the active view of the node executing the mechanism, composed by the parent, children and siblings of the node in question. Changes in this view are propagated by notifications emmitted by the overlay protocol (omitted from the pseudocode). In addition, the state contains a map denominated ``tIds'',  this map holds the metadata needed to manage the aggregation trees,composed of: (1) a difference function, which is used to remove the contributions of a certain node from an aggregated value, (2) the merge function, used for merging two or more values into an aggregated value, the query to obtain the local values, (3) the query to obtain the local values, (4) the resulting output name for the aggregated metric, (5) the periodicity to collect the aggregated value, (6) a boolean representing if the node executing the protocol is a root of the aggregation tree, and finally, (7) a map called ``aggNeighs'' which contains the peers that are interested in receicing values for that tree (previously mentioned as the aggregator nodes). Lastly, the state also contains a map denominated ``lastTimeSent'', whose values contain for each tree and neighboring node, the last time the executing node has sent a message refreshing the corresponding tree existence to it and a map called ``neighValues'', which stores the propagated neighbour values and a timestamp of the reception of these values. 

The mechanism begins is initiated with the reception of a request from the API (line \ref{alg:mon:global_agg:start_req}) with contains multiple parameters: (1) the difference function, (2) the merge function,  (3) the query to obtain the local value (4) the periodicity to perform this mechanism, and (5) the resulting metric name (to label the output values). Upon reception of this request, the node hashes the concatenation of the difference function, the merge function, the query, and the periodicity of the request, obtaining the tree ID, which will be common to every node in the tree. After the ID generation, the node checks if there already is a tree with that ID present in its local ``tIds'' map, setting as true the variable which denotes if the node should save the aggregated value locally (and consequently is a root of the tree). If there is no tree with such ID previously present, the node sets up a new ``ExportGlobalAggTimer'' with the provided periodicity and creates a new entry in the ``neighValues'' map for that tree.

\subsubsection{Tree creation and maintenance}

As previously mentioned, global aggregation allows the on-demand creation and decommission of aggregation trees. This process is achieved through a time-based mechanism, where nodes periodically refresh the trees they are the roots of via message broadcasts which are then forwarded by other nodes in the system until it reaches every node. If an aggregator node (not a root) does not receive a message from any neighbour refreshing the existence of a tree within a certain time frame, it decomissions the tree locally. 

This process is defined in alg. \ref{alg:mon:global_agg} lines \ref{alg:mon:global_agg:propag_start} to \ref{alg:mon:global_agg:propag_end}), where, as previously mentioned, nodes periodically send messages named ``RefreshGaggTree'' containing the aggregation trees they are the roots of to their children and parent and clears all entries in the ``aggNeighs'' which are older than a configured time frame, if a tree has no more entries in this map, and the ``isLocal'' flag is not set to true, the tree is removed.

Whenever the ``RefreshGaggTree'' message is received (alg. \ref{alg:mon:global_agg} line \ref{alg:mon:global_agg:propag_recv}), the receiver adds the previously unknown trees into its local ``tIds'' map and sets up a periodic ``ExportGlobalAggTimer'' for each added tree (lines \ref{alg:mon:global_agg:propag_recv_merge} to \ref{alg:mon:global_agg:propag_recv_merge_end}). Alternatively, if the tree was previously in the ``tIds'' map, the node refreshes the sender's entry in the ``aggNeighs'' map. Finally, the node removes the trees present in the message where it is also a root of and forwards the remaining trees to every node in its active view, excluding the sender. Before transmitting the trees to each node, the node checks, for each tree, if it has transmitted a ``RefreshGaggTree'' message containing the same tree in the last (configurable) time frame. If it has, then it does not propagate that tree to that node. These§ verifications are performed in order to prevent trees from being refreshed multiple times unnecessarily (as the receiving node will propagate a message refreshing the same trees later, or has refreshed it in the last seconds). 

\subsubsection{Metric propagation}

With the tree maintenance established, we now explain how the values are propagated and aggregated by each tree in the system. As previously mentioned, nodes set up an ``ExportGlobalAggTimer'' for each registered tree, whenever this timer triggers (alg.  \ref{alg:mon:global_agg} line \ref{alg:mon:global_agg:export_trigger}), the node first removes all out-of-date neighbour values for the corresponding tree (according to a configurable timeout) and evaluates the query, obtaining its local value. Then, using the neighbour values and the locally obtained value it applies the merge function and obtains the globally aggregated value, which it stores locally if configured vy the ``isLocal'' flag (lines \ref{alg:mon:global_agg:export_trigger_init_part} to \ref{alg:mon:global_agg:export_trigger_init_part_end}). Then, for each entry previously in the ``aggNeighs'' map, it sends a ``PropagateGAggValues'' message with the aggregated value minus the node's contribution and the tree ID. (lines \ref{alg:mon:global_agg:export_trigger_last_part} to \ref{alg:mon:global_agg:export_trigger_last_part_end}). 

Finally, whenever nodes receive the ``PropagateGAggValues'' (alg. \ref{alg:mon:global_agg} line \ref{alg:mon:global_agg:export_trigger}) message containing the aggregated value and the tree ID, they verify that it was sent from either the parent or the children and that the tree ID is in their local ``tIds'' map, discarding the message one of the conditions does not verify, and store the propagated value locally in the ``neighValues'' map, for later use in computing the aggregated value.

In sum, nodes who are roots of their aggregation trees will, over time, receive aggregated values from their nodes, which are essentially sent and aggregated by all other nodes using the reverse path taken by the``RefreshGaggTree'' messages. Given the fact that nodes only use their parents and children of the tree topology to forward messages (thus ensuring the tree has no cycles, as there is only a single path from any node to each other node in the system), by propagating to a neighbour the resulting aggregated value without the effects of its contribution \todo{cite akos again?}, multiple nodes in the system can simultaneously obtain the aggregated value efficiently and in a decentralized manner.

\subsection{Summary}

In this section we presented the devised aggregation protocol which leverages on the devised overlay protocol's tree structure to perform efficient propagation/aggregation of information in a decentralized manner. This protocol is coalesced by three decentralized information aggregation/collection primitives, which we believe to be useful for gathering partial or complete system information to perform decentralized resource management actions. 

The first primitive is \textbf{tree aggregation}, where nodes, when requested, form aggregation trees (with configurable range) rooted upon themselves. These trees extend only to their descendants in the original overlay protocol tree, and in case one descendant is executing the same primitive with a tree with the same range (from the descendants' perspective), it simply reuses the parent's tree to obtain the intended aggregated value. Nodes federated in these trees periodically merge their local value with their childrens' and send a message containing it to their parent.

The second primitive is \textbf{neighborhood aggregation}, where nodes collect, on-demand and in a decentralized manner, the metrics of nodes in a hop-defined range. This mechanism behaves similarly to a pub-sub system, where nodes periodically propagate messages which federate other nodes in trees rooted on themselves. Nodes in this tree propagate their local values periodically using the reverse paths taken by the federation messages. In this primitive nodes (when possible) deduplicate federation messages and multiplex metric propagations (in case multiple neighboring nodes have sent federation messages).

Lastly, the third primitive called \textbf{global aggregation} is a primitive where nodes collect and aggregate, also on-demand and in a decentralized manner, a value which corresponds to the globally aggregated value of the system. This primitive is inspired by work in the state of the art, however it relaxes constraints imposed by the original work such as performing the mechanism with only a partial set of the nodes being tree roots, in addition to allowing the technique to be performed on-demand (based on API requests).

We believe these primitives are useful for resource management decisions such as, for example, maintaining a proportion of replicas to nodes, by employing \textbf{tree aggregation} collecting all the descendants' number of replicas and number of nodes, the tree roots can, in a decentralized and independent manner, perform replication or decomission of replicas to maintain the target value. The same applies to \textbf{global aggregation}, which allows nodes to, for example, collect the total number of replicas in the system, and perform replication actions if they reach a lower than configured number. Lastly, \textbf{neighborhood aggregation} allows nodes to collect information about nearby nodes, which can also be used to improve system QOS by, for example, deploying a server closer to a client in terms of geographical distance.
