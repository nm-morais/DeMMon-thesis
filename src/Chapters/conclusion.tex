%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% conclusion.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE conclusion.tex}

\chapter{Conlusions and future work} \label{cha:conclusions_future_work}

\section{Conclusion}

The edge computing paradigm has surged as the new up-and-coming solution to the limitations imposed by the cloud. The popularity of Edge Computing has grown as it allows applications to be enriched with new features, made possible by having available hardware closer to end users. Furthermore, we believe this popularity is growing due to the size of the information produced outside the data centre, which following the current trend, will reach a point where the cloud infrastructure will start to become a bottleneck when performing timely and accurate management decisions. 

For this reason, we argue in favour of performing decentralized resource management decisions, supported by partial knowledge of the system state, and enabled by devices within and outside the data centres. This thesis is focused on enabling this behaviour, through the development of a decentralized resource monitoring and management service, targeted for performing decentralized resource management actions in cloud-edge environments.

We studied not only the-state-of-the-art regarding these systems, but also the multiple areas which we believe to be crucial for building them: (1) the types of devices composing the cloud-edge environment, (2) how to federate these devices in self-optimizing overlay networks, and (3) how to perform in-transit aggregation using these overlay networks. Through this study, we built a Decentralized Management and Monitoring (DeMMon) service, which at its’ root uses a devised overlay network protocol which employs the nodes' configured bandwidth, together with latency measurements to create and optimize a hierarchical tree-shaped network.

This overlay network was built using the first contribution of this thesis, named GO-Babel, which consists in an event-based framework designed to ease the building of distributed systems protocols. This framework is a port in Golang of Babel~\cite{babel}, however enriched with a fault detector and abstractions to perform latency measurements, which were a requirement for our protocol. Go-Babel's implementation has been validated through the conducted experimental work for the devised protocol and the baseline protocols used in the overlay protocols' evaluation. This overlay was tested in realistic testbeds, focusing on its’ capacity to establish and maintain the network even with node failures, and in its' capacity to propagate information (through broadcasting messages). The obtained results from the conducted experimental work not only show the protocols' validity, but also that the protocol can achieve higher throughput values when compared with state-of-the-art baselines in certain node counts, while remaining equal in throughput at other node counts.

Using this tree-shaped network, we implemented decentralized aggregation primitives that allow the collection of metrics across DeMMon nodes in three distinct manners: hierarchical aggregation (using the overlay tree), aggregation using a hop-based range, and global aggregation, which collects a globally aggregated value of the entire system. In our implementation, we took steps to ensure that the collection of metrics is possible to perform in an on-demand fashion and that whenever possible, nodes aggregating the same metrics reuse each others' values.

Similarly to before, we tested these features in a realistic testbed and compared their validity and applicability against a popular state of the art solution named Prometheus, which was configured with multiple tree-shaped setups. The obtained results show the validity of our solution, both with or without the presence of node failures, through achieving the correct aggregated values across multiple scenarios. Results also show that, as Prometheus configurations do not have to pay the price of maintaining the overlay network, these configurations incur lower networking costs when aggregating lower metric counts. However, as the number of metrics increases, results show that typical centralized Prometheus approaches cannot scale as the numbers of metrics emitted increase, and Prometheus setups that do so by decentralizing the aggregation procedure become plagued with multiple points of failure which require manual configuration to recover, unlike DeMMon. 

DeMMon provides access to these primitives through an API built (and a corresponding client) in WebSockets. In addition, this API allows resource management systems and other services, executing alongside DeMMon, to insert/retrieve metrics from a Time-Series database, and to request (potentially aggregated) metrics (through the previously mentioned decentralized aggregation primitives) from other nodes in the system, in which the DeMMon service is inserted into.

A goal of this work is to provide flexibility, consequently, aggregation functions which are employed to aggregate the metric values consist of user defined scripts. Furthermore, the metric values do not have a defined type (as long as they are serializable), which allows resource management applications to tailor these types to their needs, and to perform complex computations without resorting to a fixed set of aggregation functions, however at a cost of performance, when compared with better engineered state-of-the-art alternatives. In addition to this flexibility, the API also permits the execution of periodic functions to, for example, resample a time-series, or produce an aggregated value. The final presented API functionality is the ability for clients to install alarms. These allow clients to get notified whenever an issued condition is verified and prevent clients from spending resources performing periodic verifications. 

Finally, as the initial vision of this thesis was of pairing DeMMon with a decentralized service deployment system built by a colleague, we contributed to this vision through the collaborative creation of a benchmark edge-enabled application, intended to test the complete stack. This benchmark application aims to provide a decentralized implementation, through microservices, of an interactive multiplayer game with, functionality inspired from the popular game PokemonGO. We believe this contribution helps tackle what is currently an obstacle for the development of these systems, given that, to our knowledge, there were no free and open-source realistic implementations of edge-enabled interactive applications that we could use to test the complete envisioned software stack.

\section{Future work}

As future work, there are ideas prevenient from both the initial thesis vision and the development of our work. 
Regarding the overlay protocol, we believe there are multiple venues that may be taken, either to improve the existing protocol or to devise a new one based on the current presented work. First, we believe there are possible improvements to be had regarding reducing the necessary messages for performing maintenance of the established logical connections. This can be achieved through, for example, stopping the periodic emission of certain messages whenever the logical connections are established, consequently reducing the networking cost of maintaining the overlay. Second, we believe that it may be possible to insert additional mechanisms as an attempt to balance the overlay tree, aiming to decrease the number of hops and increase the latency incurred by messages sent in information dissemination scenarios. Finally, we believe there is the need to address the need for manual configuration and fault-recovery of the bootstrap nodes, this can be overcome either by creating a new specialized protocol to perform this function, or by embedding this feature into the protocol.

We also believe there is interesting future work regarding the devised aggregation primitives, from adding new efficient aggregation primitives that rely on the abstractions provided by the tree to, similarly to the overlay protocol, reduce the overhead of maintaining the aggregation mechanisms. This can be realized, for example, by maintaining established aggregation trees by sending messages solely when nodes switch parent, nodes crash, or links fail by not periodically emitting messages to maintain the aggregation trees, instead of doing so with a periodic mechanism.

We believe another venue worth pursuing is to optimize the query evaluation process, namely experimenting with alternative libraries that allow the execution of user-defined code, or creating our own, tailored for our needs. In addition, we believe it would be valuable to replace the metric propagation protocol with a more efficient serialization protocol (possibly not JSON-based).

Finally, as future work we plan to improve the stability of the built components by creating unit and integration tests, and to further separate the components through interfaces which materialize this solution, such that each individual component can be replaced with another that satisfies the same interface. We believe our solution can be improved in this regard through, for example, separating the offered broadcast primitives from the membership protocol. 