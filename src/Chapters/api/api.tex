
The API is the last module of the devised framework. As previously mentioned at the beginning of this chapter, the purpose of this module is to expose the functionality of the remaining components of the framework by mediating the interactions between the clients and the remaining modules via well-defined operations. In this section, we provide a brief overview of the API implementation and summarise its most relevant operations. 

\subsection{Overview}

This API is coalesced by a message-based protocol performed via WebSockets~\cite{websocketsRFC}. The choice of using a message-based protocol is motivated by the fact that, contrary to traditional HTTP APIs, messages enable clients to receive events sent by the DeMMon servers (without requiring an explicit request). This feature is essential for both alerting (as triggered alarms need to be propagated to the clients that registered these alarms) and for issuing events such as active view changes (from the overlay protocol, defined in Section~\ref{sec:overlay_network}) to subscribed clients. Consequently, in this API, the client must first establish a connection with the server in order to perform operations. This is done via an HTTP request, used for establishing the WebSockets connection. In order to test the provided API and the capabilities of the framework, we also devised a client which performs the operations, available on~\cite{demmon-client-repo}.

When connected, clients and servers exchange JSON formatted messages that contain messages that trigger two types of operations: the first is a \textbf{request}, which is similar to an HTTP request, where the client creates a request and assigns it an ID which it sends to the DeMMon server via a WebSockets message. When the server receives the message, it processes it and sends back to the client a reply message containing the ID and the reply contents using the same established connection. Requests are used, for example, for querying metrics. The second type of operation is a \textbf{subscription}, which initially performs similarly to a request, hovever, in this operation, the server, posterior to the initial request, may send messages to the client (without requiring a request) containing events related to the issued subscription. This type of operation is used by clients for receiving events, for example, for both clients wanting to receive active view changes or for clients installing alarms and then receiving updates to changes in these alarms.

With this, we now provide a brief overview of the more relevant operations exposed by the DeMMon API.

\subsection{API operations}

\begin{enumerate}
    \item \textbf{Install or remove buckets} These operations, as their name indicates, insert or remove buckets from the time series database. As previously mentioned in subsection~\ref{sec:mon_module:tsdb}, buckets are containers for all time-series data with a certain name, periodicity and capacity. Whenever a ``create bucket'' operation is issued for a bucket with a name that collides with a pre-existing bucket (with a different periodicity), an error message is returned to the client. This feature allows resource management applications to specify the periodicity at which a certain metric value is stored, and allows the TSDB to evict stale values from the stored time-series.
    
    \item \textbf{Retrieve and insert metric values}. These two operations, performed via requests, add or extract values from the time series database. When these requests are received, the values are inserted directly in the corresponding time series. The retrieval of metric values is also performed via a request containing a query in the query language. This query is passed to the monitoring module (specifically the metric engine) for processing. When the query has finished being processed by the metric engine, the result is sent back to the client via a message.
    
    \item \textbf{Subscription to active view updates}. This operation, as the name denotes, is performed via a subscription, where the initial reply contains the current view of the server. Then, whenever there is a change in the active view of the DeMMon server's overlay protocol, the client is sent a message containing the changes in the active view. This feature is useful for resource management systems as it provides them with a set of nodes to cooperate with that have low latency values.
    
    \item \textbf{Install continuous query}. This operation allows the installation of a continuous query. Continuous queries is a feature that, when installed, evaluates a query at a specified periodicity and inserts the return values into the time series database under a specified name. This operation is useful for applications that wish to, for example, resample their data (i.e. to longer periodicities) or wish to calculate a certain aggregated value at specific intervals. 

    \item \textbf{Send and receive broadcast messages}. As the name indicates, these two operations refer to issuing and receiving broadcast messages. The emission of new broadcast messages is done via a request containing the message contents, the message TTL and the message ID (a text-based field). Whenever this request is received, the API sends a request containing the supplied message to the overlay protocol, which, in turn, propagates the message contents via its active connections (until the message TTL is 0). Broadcast messages are propagated and forwarded to peers in the active view in a similar manner to the subscription messages (described in Section~\ref{sec:mon_protocol:neigh_agg}). Finally, nodes can perform \textbf{Subscriptions to broadcast message receptions}, which are subscription operations for clients that wish to receive all messages with a certain ID that are received by the DeMMon overlay protocol. This is useful in case resource management systems wish to propagate information to other nodes in the system without incurring the additional overhead of establishing new connections.
    
    \item \textbf{Install Alarm}. This operation is performed via a subscription containing the parameters described in Section~\ref{sec:mon_module:alarm_monitor}, whenever a client issues this operation, the API assigns a new ID to the alarm and adds it to the alarm manager, where it is periodically verified. After this, if in any verification of the alarm fires, the alarm manager notifies the API, which correspondingly sends a message to the client with the firing alarm's ID.

    \item \textbf{Install and removal of neighbourhood aggregation sets}. These operations manage the operation of the neighbourhood aggregation algorithm defined in Section~\ref{sec:mon_protocol:neigh_agg}. Whenever a neighbourhood aggregation set is installed, it is assigned an ID and a reply is sent to the client with the generated ID. When the client wishes to stop the collection of these values, it issues a removal request containing the originally assigned ID.

    \item \textbf{Install and removal of global aggregation function}. These operations initiate and stop the global aggregation procedure (described in Section~\ref{sec:mon_protocol:global_agg}), the behaviour of this operation, in regard to the interaction between the client and the server, is similar to the neighbourhood aggregation set. 
    
    \item \textbf{Install and remove tree aggregation function}. This is the last detailed operation of the DeMMOn API, and triggers the operation of the protocol presented in Section~\ref{sec:mon_protocol:tree_agg} which, in terms of interaction between the client and the server, also behaves similarly to both the neighbourhood and global aggregation requests.
    
\end{enumerate}

% In addition to this API and its client, we also made available a wrapper around the API client, called an Exporter. The exporter offers operations for applications to register variables, which are periodically monitored, and their 

% eases the process of monitoring variable values and exporting the corresponding metrics to a DeMMon server periodically.


% the process of exporting metrics to and from the DeMMon nodes by automatically installing the necessary buckets, and performing the requests periodically to publish the metrics to the DeMMon node. 

\subsection{Summary}

In this section, we have presented an overview of the operations exposed by the DeMMon API. We began by providing a brief explanation behind the choice of WebSockets~\cite{websocketsRFC} as a way to enable message-based communication between the API and the client. Next, we enumerated what we believe to be the most relevant operations of the API, and for each enumerated operation, we provided a brief explanation of its behaviour regarding both the effect on the remaining components and the model of interaction between the client and the server. 